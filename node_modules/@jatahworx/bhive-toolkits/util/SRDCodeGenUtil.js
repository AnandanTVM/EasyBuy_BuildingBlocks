let statusCodes = require('http-status-codes');
let pathToRegx = require('path-to-regexp');
const soap = require('strong-soap').soap;
const fs = require('fs');
module.exports = class SRDCodeGenUtils {

    getValueFromTypedInput({
        type,
        value,
        nullable,
        nullableValue,
        constant
    }) {
        if ((typeof type == 'undefined') || (type === 'num' && typeof value != 'number') &&
            (type === 'bool' && typeof value != 'boolean') ||
            type === 'undef') {
            return undefined;
        }
        if (constant === true) {
            return type;
        }
        if (value === '') {
            if (nullable) return nullableValue;
        }
        if (type === 'str' || type === 'array') {
            return JSON.stringify(value);
        }
        if (type.startsWith('bh')) {
            if (value === '') {
                if (nullable) return nullableValue;
                return type;
            }
            return type + '.' + value;
        }
        if (type === 'literal') {
            return value;
        }
        if (type === 'num') {
            return Number(value);
        }
        if (type === 'bool') {
            if (value === '') return false;
            return JSON.parse(value);
        }
        if (type === 'null') {
            return null;
        }
        if (type === 'process.env' || type === 'server_env') {
            return `__ssd__env__process.env.${value}__ssd__env__end`;
        }
        if (type === 'environment' || type === 'client_env') {
            return `__csd__env__bh.system.environment.properties.${value}__csd__env__end`;
        }
        if (type === 're') {
            return '/' + value + '/';
        }
        if (type === 'any') {
            return value == '' ? 'undefined' : value;
        }
        if (type === 'select') {
            return typeof value === 'string' ? value : JSON.stringify(value);
        }
        throw new Error('"type" Does Not Exist. Please Supply A Valid Type.');
    }

    /**
     * 
     * @param {*} typedInputs {key: {type: string, value: any}} | [{key: {type: string, value: any}}]
     */
    getTypedInputValues(typedInputs) {
        // console.log(typedInputs);
        let obj = {};
        if (typeof typedInputs != 'object' && !Array.isArray(typedInputs)) {
            throw new Error('Invalid arguments. typedInputs should of type Object of typedInputs or Array of typedInputs');
        }
        // returns [{key: typedValue}]
        if (Array.isArray(typedInputs)) {
            for (let i = 0; i < typedInputs.length; i++) {
                if (typedInputs[i]) {
                    let k = Object.keys(typedInputs[i])[0];
                    if (k) {
                        if (!typedInputs[i][k].type || !typedInputs[i][k].value) {
                            throw new Error('Invalid typedInput. It should have valid type and value');
                        }
                        let v = this.getValueFromTypedInput(typedInputs[i][k]);
                        if (v) {
                            obj[k] = this.getValueFromTypedInput(typedInputs[i][k]);
                        }
                    }
                }
            }
            return obj;
        }
        // returns {key: typedValue}
        for (const [key, value] of Object.entries(typedInputs)) {
            let v = this.getValueFromTypedInput(value);
            if (v) {
                obj[key] = v;
            }
        }
        return obj;
    }

    assignValueToObjectPathForTypedInput(node, typedInputConstIndicator) {
        if (node && node[typedInputConstIndicator] && typedInputConstIndicator) {
            Object.keys(node[typedInputConstIndicator]).map(objectPath => {
				const v = node[objectPath];
                node = this.setValueToObjectPath(node, objectPath, v);
            });
        }
        return node;
    }

    assignValueToObjectPathForTypedInputConfigNode(node, typedInputConstIndicator) {
        if (node && node[typedInputConstIndicator] && typedInputConstIndicator) {
            Object.keys(node[typedInputConstIndicator]).map(objectPath => {
                if (node[typedInputConstIndicator][objectPath].type !== 'str') {
					const v = node[objectPath];
                    node = this.setValueToObjectPath(node, objectPath, v);
                } else {
                    let value = node[typedInputConstIndicator][objectPath].value;
                    if (!value && node[typedInputConstIndicator][objectPath].nullable) {
                        value = node[typedInputConstIndicator][objectPath].nullableValue;
                    }
                    node = this.setValueToObjectPath(node, objectPath, value);
                }
            });
        }
        return node;
    }

	/**
	 * @description Sets the passed `value` on the `obj[keyPath]` and on the `obj[keyPathParts[0]][keyPathParts[1]]...`.
	 * where, `keyPathParts` is an array got by splitting the `keyPath` on `.`s.
	 * @param {*} obj The object on which to set the value 
	 * @param {string} keyPath The path of the property to which the `value` is to be assigned
	 * @param {*} value The value for the `keyPath`
	 * 
	 * @returns {*} the passes `obj` with `obj[keyPath]` and `obj[keyPathParts[0]][keyPathParts[1]]...` set to `value`
	 */
    setValueToObjectPath(obj, keyPath, value) {
		// Setting the value on the object itself before going deep
		obj[keyPath] = value;
        obj = typeof obj === 'object' ? obj : {};
        const keys = keyPath.split('.');
        let currentObj = obj;
        for (let i = 0; i < keys.length - 1; i++) {
            const key = keys[i];
            if (typeof currentObj[key] != 'object') {
                currentObj[key] = {};
            }
            currentObj = currentObj[key];
        }
        currentObj[keys[keys.length - 1]] = value;
        return obj;
    }

    isValidHttpStatusCode(httpStatusCode) {
        if (isNaN(Number(httpStatusCode))) return false;
        return Object.values(statusCodes).includes(Number(httpStatusCode));
    }

    cssQueryFilter(q) {
        if (typeof q === 'string' && q.includes('.')) {
            return q.replace(new RegExp('\\.', 'g'), '\\.');
        }
        return q;
    }
    getPathArray(path) {
        return pathToRegx.parse(path);

    }

	escapeTheEscapeChar(str) {
		return str.replace(/(\\)/g, '\\\\');
    }
    getWSDLOperations(path, options) {
        return new Promise((resolve, reject) => {
            if (fs.existsSync(path)) {
                soap.createClient(path, options, (err, client) => {
                    if (err) {
                        return reject({ err });
                    }
                    return resolve({ webServiceName: client.wsdl.definitions.$name, ...this.__getMethodsAndParams(Object.keys(client.wsdl.services), client.describe()) });
                });
            } else {
                return reject('File does not exist.');
            }
        });
    }

    __getMethodsAndParams(services, describeObj) {
        let serviceVersions = []; let parametersList = [];
        const clientDescribedObj = {};
        for (let j = 0; j < services.length; j++) {
            const _serviceName = services[j];
            serviceVersions = Object.keys(describeObj[_serviceName]);
            clientDescribedObj[_serviceName] = [];
            for (let i = 0; i < serviceVersions.length; i++) {
                clientDescribedObj[_serviceName].push({ value: serviceVersions[i], displayValue: serviceVersions[i], operations: [] })
                const _operationsList = Object.keys(describeObj[_serviceName][serviceVersions[i]]);
                for (let y = 0; y < _operationsList.length; y++) {
                    const _operationObj = describeObj[_serviceName][serviceVersions[i]][_operationsList[y]];
                    const paramsList = this.__getParams(_operationObj);
                    clientDescribedObj[_serviceName][i].operations.push({ value: _operationObj.name, displayValue: _operationObj.name, paramters: paramsList });
                    parametersList.push(...paramsList);
                    // operations.push({ value: _operationObj.name, version: _operationObj.soapVersion, displayValue: `${_operationObj.name} ${_operationObj.soapVersion}`, paramters: this.__getParams(_operationObj) })
                }
            }
        }
        return { operationsInfo: clientDescribedObj, parametersList: this.removeDuplicateParameters(parametersList) };
    }

    removeDuplicateParameters(parametersList = []) {
        return parametersList.filter((item, index, self) =>
            index === self.findIndex((t) => (
                t.name === item.name
            ))
        );
    }

    __getParams(operationObj) {
        if (operationObj.hasOwnProperty('input') && operationObj.input.hasOwnProperty('body') &&
            operationObj.input.body.hasOwnProperty('elements')) {
            const paramters = [];
            for (let i = 0; i < operationObj.input.body.elements.length; i++) {
                paramters.push({ name: 'methodParameters.' + operationObj.input.body.elements[i].qname.name, label: operationObj.input.body.elements[i].qname.name });
            }
            return paramters;
        } else {
            return [];
        }
    }
	// }

  /**
   * Creates a string that looks like an object which can be directly written to a file
   * from the given `entity` object.
   * This is quite different from `JSON.stringify` in that the non-objects can be optionally stringified.
   * @param {*} entity An object (can be a nested)
   * @param {boolean} [stringifyNonObjects] whether to stringify the non-object values or not. Defaults to `false`
   * @return {string} String generated from obj
   */
	getObjAsCodeString(entity, stringifyNonObjects = false) {
		let returnValue = entity;
		if (!this.__isKVObject(entity) && !Array.isArray(entity)) {
			returnValue = stringifyNonObjects ? JSON.stringify(entity) : entity;
		} else if (Array.isArray(entity)) {
			returnValue = entity.reduce((r, e, i, array) =>
				r += `${this.getObjAsCodeString(e, stringifyNonObjects)}${array.length - 1 !== i ? ',' : ''}`, '[') +
				']';
		} else if (this.__isKVObject(entity)) {
			returnValue = Object.entries(entity)
				.reduce((r, e, i, array) =>
					r += `${e[0]}: ${this.getObjAsCodeString(e[1], stringifyNonObjects)}${array.length - 1 !== i ? ',' : ''}`, '{') +
				'}';
		}
		return returnValue;
	}

	__isKVObject(entity) {
		return !!(entity !== undefined &&
			entity !== null &&
			!Array.isArray(entity) &&
			typeof entity === 'object' &&
			Object.keys(entity).length);
	}
};