<script type="text/x-red" data-template-name="ExecuteSql">
    <!-- database config -->
<div id="node-row-databaseConfig-container" class="editor-form-row"
    style="display:flex; flex-direction:column; height: 2.6rem">
    <label style="width: auto;" for="node-input-databaseConfig" class="editor-form-row-label">
        <span data-i18n="executeSql.label.connection-name"></span>
    </label>
    <input type="text" style="width: 100%" id="node-input-databaseConfig">
</div>

<!-- Sql type -->
<!-- single query mapping -->
<div id="single-query-container" class="editor-form-row">
    <label for="node-input-single-query" class="editor-form-row-label"><span
            data-i18n="executeSql.label.query-mapping"></span></label>
    <div class="form-row" id="node-input-single-query-container">
        <input type="text" id="node-input-single-query" class="node-input-property typed-input-width"
            style="width: 100% !important" />
    </div>
</div>

<!-- Params  -->
<div id="props-section-container" class="http-container">
    <div style="display: flex">
        <label for="params-props-section" class="editor-form-row-label">
            <span class="props-title" data-i18n="common.label.params-title"></span>
        </label>
        <image style="display:none !important;" id="node-input-params-button" title="Map" />
        </image>
    </div>
    <div class="form-row http-element-container field-wrapper-typedInput display-none editor-form-row"
        id="node-input-params-map-container">
        <input type="text" id="node-input-params-map" class="node-input-property typed-input-width"
            style="width: 100% !important" />
        <input type="hidden" id="node-input-outputs" />
        <button class="map-button-wrp" style="height: 100%; margin-top: 0.75em;">
            <image class="map-button proxy-map-value-toggle-params" title="Value" src="assets/serviceDesigner/edit.svg"
                style="margin-bottom: 0.75em;"></image>
        </button>
    </div>
    <div id="params-props-section" class="props-section">
        <div class="add-section params-section">
            <div class="srd-editableList-add-kv-wrp">
                <input type="text" class="property-key" name="params-key" style="width: 98%">
            </div>
            <button class="map-button-wrp" style="margin-left: 0em;">
                <image class="map-button proxy-map-value-toggle-params" title="Map"
                    src="assets/serviceDesigner/refresh.svg"></image>
            </button>
        </div>
        <div class="properties-container" validatesform="true">
            <ol id="params-properties-content"></ol>
        </div>
        <div class="error-msg-container">
            <span class="list-keys-invalid">{{Editable List Invalid Message}}</span>
        </div>
    </div>
</div>

<!-- Result Mapping -->
<div class="http-container editor-form-row">
    <label for="node-input-result-mapping" class="editor-form-row-label"><span
            data-i18n="common.label.result-mapping"></span></label>
    <div class="form-row  field-wrapper-typedInput http-element-container" id="node-input-result-mapping">
        <input type="text" id="node-input-result-map" class="node-input-property typed-input-width"
            style="width: 100% !important" />
    </div>
    <div class="error-msg-container"><span id="invalid-resultmapping-mapping-error"
            class="invalid-select display-none">Invalid Mapping</span></div>
</div>

</script>
<script type="text/javascript">

    registerNode({
        nodeType: 'ExecuteSql',
        serviceType: 'server',
        nodeDef: {
            category: 'Storage',
            color: "#1666e6",
            defaults: {
                // input text fields
                name: { value: '', required: false },
                databaseConfig: { type: 'db-config', value: {}, required: true, options: { type: 'mssql', dbCategory: 'sql' } },
                queryType: { value: '' },
                resultMap: { value: '' },
                multipleQuery: { value: '' },
                singleQuery: { value: '' },
                inputs: { value: 1 },
                outputs: { value: 1 },
                params: { value: [] },
                paramMappingObj: { value: {} },
                dbType: { value: '' }
            },
            inputs: 1,
            outputs: 1,
            icon: "ndefault-sql/sql-node.svg",
            label: function (SRD) {
                return this.name || 'SQL'
            },
            paletteLabel: function (SRD) {
                return this.name || 'SQL'
            },
            oneditprepare: function (SRD) {
                const node = this;

                const types = [
                    { value: "bh", label: 'bh.', validate: SRD.validators.typedInput('bh', true) },
                    { value: "bh.input", label: 'bh.input.', validate: SRD.validators.typedInput('bh.input', true) },
                    { value: "bh.local", label: 'bh.local.', validate: SRD.validators.typedInput('bh.local', true) }
                ];
                const paramsTypes = [
                    { value: "bh", label: 'bh.', validate: SRD.validators.typedInput('bh') },
                    { value: "bh.input", label: 'bh.input.', validate: SRD.validators.typedInput('bh.input') },
                    { value: "bh.local", label: 'bh.local.', validate: SRD.validators.typedInput('bh.local') }
                ];
                node.tempVarStore = { paramsVariables: [] };
                isTableValid = true;
                const srcs = {
                    Map: 'assets/serviceDesigner/refresh.svg',
                    Value: 'assets/serviceDesigner/edit.svg'
                }
                function validateForm() {
					SRD.defaults.validateForm(true);
                }

                function updateTypedInputValues(ele, mappingObj) {
                    if (node[mappingObj] && node[mappingObj].hasOwnProperty('type')) {
                        ele.typedInput('type', node[mappingObj].type);
                        ele.typedInput('value', node[mappingObj].value);
                    }
                }

				/* Function takes ids and values to compoares. If condition statisfies then it toggle the fields*/
                function toggleFields(id1, id2, actualValue, valueToCompare, buttonId, buttonValue) {
                    if (valueToCompare == actualValue) {
                        $(`#${id1}`).addClass('display-none');
                        $(`#${id2}`).removeClass('display-none');
                        $(`#${buttonId}`).attr('title', buttonValue);
                    } else {
                        $(`#${id2}`).addClass('display-none');
                        $(`#${id1}`).removeClass('display-none');
                        $(`#${buttonId}`).attr('title', actualValue)
                    }
                }

                function assignProperIcon(buttonId) {
                    if ($(`#${buttonId}`).attr('title') === 'Map') {
                        $(`#${buttonId}`).attr('src', 'assets/serviceDesigner/refresh.svg');
                    } else {
                        $(`#${buttonId}`).attr('src', 'assets/serviceDesigner/edit.svg');
                    }
                }


                /* get called when there are any  params are present*/
                function populateExistingVariables(sectionName, variablesObjectArr) {
                    if (variablesObjectArr && variablesObjectArr instanceof Array) {
                        for (let row of variablesObjectArr)
                            $(`#${sectionName}-properties-content`).editableList('addItem', { rowData: row, validator: false });
                    }
                }

                /* Function to update the typedInput type and values*/
                function updateTypedInpuTypeAndValue(element, mappingObj, buttonId, id1, id2) {
                    element.typedInput('type', mappingObj['type']);
                    element.typedInput('value', mappingObj['value']);
                    $(`#${buttonId}`).attr('title', 'Value')
                    assignProperIcon(buttonId);
                    $(`#${id1}`).addClass('display-none');
                    $(`#${id2}`).removeClass('display-none');
                }

                /* Single Query */
                const singleQueryTypedInputEle = $('#node-input-single-query').typedInput({ types: types.concat([{ value: 'str', label: 'string', validate: /[^\s]+/ }]), noformvalidation: false });
                updateTypedInputValues(singleQueryTypedInputEle, 'singleQuery')

                /*  Result mapping */
                const resultMapping = $('#node-input-result-map').typedInput({ types: types , noformvalidation: false });
                updateTypedInputValues(resultMapping, 'resultMap')

                /* radio button */
                function toggleQueryTypeBlock(value) {
                    if (value == 'single') {
                        $('#multiple-query-container').hide()
                        $('#single-query-container').show()
                    } else {
                        $('#multiple-query-container').show()
                        $('#single-query-container').hide()
                    }
                }

                function radioBtnVal() {
                    const type = node.queryType ? node.queryType : 'single'
                    $(`#${type}-query   `).attr('checked', true);
                    toggleQueryTypeBlock(type);
                }

                radioBtnVal();

                $('input[type=radio][name=query-type]').change(function () {
                    toggleQueryTypeBlock(this.value);
                });
                /* Params */
                /* Creates the headers and params editable list section*/
                function decorateAndPopulatePropsSection(sectionName, dialogForm) {
                    /* Properties add section key-value fields */
                    let startKvWrp = $(`#${sectionName}-props-section .srd-editableList-add-kv-wrp`);
                    let keyField = $(`#${sectionName}-props-section .property-key`).inputField({
                        placeholder: SRD._('common.label.key'),
                        validatorRegexp: /[^\s]+/
                    });

                    /* Properties List */
                    let propertiesContainer = $(`#${sectionName}-props-section .properties-container`);
                    let invalidListMsg = $(`#${sectionName}-props-section .list-keys-invalid`).css({ 'visibility': 'hidden' });

                    let propertiesHeaderContainer = $(`<div class="properties-header-container"></div>`).prependTo(propertiesContainer);

                    let headers = $(`
                <div class="header">No.</div>
                <div class="wide-header ">Params</div>
                `).appendTo(propertiesHeaderContainer);

                    let varArrType = 'paramsVariables';

                    function updateTempVarStore(prop, val, currentRowIdArr, setRest) {
                        for (let i in node.tempVarStore[varArrType]) {
                            if (currentRowIdArr.includes(node.tempVarStore[varArrType][i]['rowId'])) {
                                node.tempVarStore[varArrType][i][prop] = val;
                                if (setRest === undefined) {
                                    return i;
                                }
                            } else if (setRest !== undefined) {
                                node.tempVarStore[varArrType][i][prop] = setRest;
                            }
                        }
                    }

                    function ultimateValidator() {
                        SRD.defaults.validateForm(SRD.validators.editableList(propertiesContainer, propsContent, {
                            checkValidityOn: node.tempVarStore[varArrType],
                            errorMsgContainer: invalidListMsg
                        }));
                    }

                    let propsContent = $(`#${sectionName}-properties-content`).data({ valid: true, isValid: true, isUnique: true });
                    propsContent.editableList({
                        addItem: function (container, i, data, miscElms) {
                            let rowData = data.rowData ? data.rowData : data;
                            let value = rowData.length ? rowData : keyField.val()
                            /* property list's "key" field */
                            let listKey = $(`<input type="text"/>`).appendTo(container).inputField({
                                wrapperAttr: { style: 'width: 80%;' },
                                validatorRegexp: /[^\s]+/,
                                inputClassList: "property-key",
                                value: value,
                                updations: function (elemData, inputVal) {
                                    let index = updateTempVarStore('key', inputVal, container.data().data.rowData.rowId);
                                    node.tempVarStore[varArrType][index].valid = elemData.valid;
                                    container.data('data', { rowData: node.tempVarStore[varArrType][index] });
                                    ultimateValidator();
                                }
                            });

                            let dataObj = {
                                key: listKey.val(),
                                rowId: rowData.rowId || SRD.nodes.id(),
                                valid: true
                            };

                            node.tempVarStore[varArrType].push(dataObj);
                            propertiesContainer.show();
                            container.attr('id', dataObj.rowId).data('data', { rowData: dataObj });
                            $('.property-row .field-floating-placeholder').remove();
                            /* Clear the "Add" Section input fields */
                            keyField.val('');
                            // outputToggle.find('input').prop('checked', false);
                            $('.srd-delete-icon').addClass('http-delete-icon')
                            if (miscElms.deleteBtn) {
                                miscElms.deleteBtn.css({ "margin-right": "1em" })
                            }
                            if (miscElms.sortableHandle) {
                                miscElms.sortableHandle.css({
                                    'padding-top': '1em',
                                    'right': '.75em',
                                    "width": '1em'
                                })
                            }
                        },
                        showAddBtnLabel: false,
                        removable: true,
                        scrollOnAdd: true,
                        sortable: true,
                        removeItem: function (data) {
                            node.tempVarStore[varArrType] = node.tempVarStore[varArrType].filter(vObj => vObj['rowId'] !== data.rowData.rowId);
                            ultimateValidator();
                            if (node.tempVarStore[varArrType].length === 0) {
                                $(`#${sectionName}-props-section .properties-container`).hide();
                            }
                        },
                        validator: function () {
                            let keyToValidate = keyField.val();
                            if (!keyToValidate.match(keyField.inputField('option', 'validatorRegexp'))) {
                                SRD.dialogService.openSnackBar('Invalid Key! It Should Contain Atleast One Character.');
                                return false;
                            }
                            return true;
                        },
                        sortItems: function (items) {
                            let tempstorage = []
                            let itemsList = $('#params-properties-content').editableList('items')
                            itemsList.each(function (i) {
                                $(this).find(".node-input-rule-index").html(i + 1);
                                var data = $(this).data('data');
                                tempstorage.push(data.rowData);
                            })
                            node.tempVarStore.paramsVariables = tempstorage;
                        }
                    });
                }


                /* Params TypedInput*/
                const paramsTypedInputEle = $('#node-input-params-map').typedInput({ types: paramsTypes, noformvalidation: false });
                $('.proxy-map-value-toggle-params').click((eventObj) => {
                    let text = $('#node-input-params-button').attr('title');
					toggleFields('params-props-section', 'node-input-params-map-container', 'Map', text, 'node-input-params-button', 'Value');
					validateForm();
                });
                // decorateAndPopulatePropsSection('headers');
                decorateAndPopulatePropsSection('params');
                $('.add-prop-icon').addClass('add-prop-http-icon');
                $('.add-prop-text').addClass('add-prop-http-text');
                $('.add-prop-btn').addClass('add-button-http');

                /* Hide the properties list by default. It will be displayed whenever 'addItem' runs */
                $('#params-props-section .properties-container').hide();


                if (this.paramMappingObj && this.paramMappingObj.hasOwnProperty('type')) {
                    updateTypedInpuTypeAndValue(paramsTypedInputEle, this.paramMappingObj, 'node-input-params-button', 'params-props-section', 'node-input-params-map-container');
                } else {
                    populateExistingVariables('params', this.params);
                }

                $('.add-prop-btn-wrp').each(function (i, elem) {
                    $(elem).css('margin-left', '0.5em')
                        .insertBefore($('.add-section .map-button-wrp')[i]);
                });

                $('.srd-editableList-add-kv-wrp .field-wrapper').width('100%')

                $('#dialog-form').attr('novalidate', 'novalidate');
                validateForm();
            },
            onpropertieschange: function (changes, valid, SRD) {
                const node = this;
                //asign DB type 
                node.dbType = SRD.nodes.node(node.databaseConfig).selectedDB;
            },
            oneditsave(SRD) {
                const node = this;
                function typedIpEVal(elem) {
                    val = elem.typedInput('value').trim();
                    return ({
                        type: elem.typedInput('type'),
                        value: val
                    });
                }

                node.queryType = $('input[type=radio]:checked').val();
                node.resultMap = typedIpEVal($('#node-input-result-map'));
                // node.multipleQuery = typedIpEVal($('#node-input-multiple-query'));
                node.singleQuery = typedIpEVal($('#node-input-single-query'));
                /* Params */
                if ($('#node-input-params-button').attr('title') == 'Map') {
                    node.params = [];
                    for (const param of this.tempVarStore.paramsVariables) {
                        node.params.push(param.key);
                    }
                    node.paramMappingObj = undefined;

                } else {
                    // updateMappingValue('node-input-params-map', 'paramMapping', 'paramMappingObj');
                    node.paramMappingObj = {};
                    node.paramMappingObj.type = $(`#node-input-params-map`).typedInput('type');
                    node.paramMappingObj.value = $(`#node-input-params-map`).typedInput('value');
                    node.params = undefined;
                }

                delete node.tempVarStore;
            },
            oneditcancel: function () {
                let node = this;
                delete node.tempVarStore;
            },
            oneditresize: function (size) {
                $('.properties-container .wide-header').width($('.properties-container .field-wrapper').width()).css({
                    'margin-left': '1em'
                });
            },
            docsLink: 'mssql-node'
        }
    });
</script>