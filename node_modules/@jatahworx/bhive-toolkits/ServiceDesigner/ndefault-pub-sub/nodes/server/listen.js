let BaseComponent = require('@jatahworx/bhive-toolkits').BaseComponent;

module.exports = class listen extends BaseComponent {
	constructor(constructorOptions) {
		super(
			constructorOptions.id,
			constructorOptions.name,
			'neutrinos_service_designer_' + 'listen',

			'listen'
		);
        this.nodeType = BaseComponent.nodeTypes.START;
        this.constructorOptions = constructorOptions;
	}
	/**
	 * returns Array of {
	 *  libraryName: string,
	 *  modules: [string],
	 *  alias: string
	 * }
	 */
	generateImports(rootPaths) {
		return [
            {
            library: rootPaths.pathToUtilsRoot + '/ndefault-pub-sub/listen/listen',
            modules:[
                "pubsubUtil"
            ]
            }
        ];
	}
	/**
	 * @typedef {Object} ServiceVariable
	 * @property {string} name - Name of the variable
	 * @property {string} [type] - Type of the variable
	 * @property {any} [value] - Initial value to assign to the variable
	 */

	/**
	 * @returns {Array<ServiceVariable>}
	 */
	declareVariables() {
		console.log(
			this.name,
			'Base Class declare variable called.. returning empty array'
		);
		return [];
	}

	generateSnippet(serviceType, serviceClassTemplate) {
        return  (``);
	}
    
    getListenerSnippet() {
		if (!this.constructorOptions.eventName ) {
            throw new Error(`Listen Node: Event name can't be empty`);
        }
        let listenerSnippet = this.constructorOptions.listenerType === 'on' ?
        `pubsubUtil.getInstance().on` : `pubsubUtil.getInstance().once` ;
		return `${listenerSnippet}(${this.constructorOptions.eventName}, async data => this.${this.constructorOptions.functionName}(data))`;
	}

	getCallTemplate() {
		console.log(
			this.name,
			'Base Class generation called.. returning empty call template..'
		);
		return '';
	}

	populateConfig(configObj) {}

	/**
	 * reutrn [{name: '', version: ''}]
	 */
	updatePackageJSON() {
		return [];
	}

	updateTemplate(serviceClassTemplate) {
		// base calss update Template. return as is;
		return serviceClassTemplate;
	}

	getErrorTemplate() {
		return `
        export class errorCheck {
            //appendnew_node
        }
        `;
	}
};
