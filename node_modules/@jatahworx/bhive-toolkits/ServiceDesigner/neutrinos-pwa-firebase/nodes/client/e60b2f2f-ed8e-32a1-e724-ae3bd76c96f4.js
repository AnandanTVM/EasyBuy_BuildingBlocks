let BaseComponent = require('@jatahworx/bhive-toolkits').BaseComponent;

module.exports = class subscription extends BaseComponent {
	constructor(constructorOptions) {
		super(
			constructorOptions.id,
			constructorOptions.name,
			'neutrinos_service_designer_' + 'subscription',

			'e60b2f2f-ed8e-32a1-e724-ae3bd76c96f4'
		);
        this.nodeType = BaseComponent.nodeTypes.START;
        this.constructorOptions = constructorOptions;
		/* Eg to get attribute values
                                              (Attribute Name)
           this.remotePath = constructorOptions.remotePath
        */
	}
	/**
	 * @param {{depth: number, pathToUtilsRoot: string, pathToServiceRoot: string}} rootPaths
	 * @returns {{
	 *  library: string,
	 *  modules?: [string],
	 *  alias?: string,
	 *  default? string,
	 * }[]} imports
	 */
	generateImports(rootPaths) {
		/*Eg to import a util...=> rootPaths.pathToUtilsRoot + '/(gen package name)/nodeName/utilname'
    return [{               
      library: rootPaths.pathToUtilsRoot + '/neutrinos-sftp/59897528-50aa-e203-83db-4bd6c97d35af/sftp',
      modules:[
          "sftpUtil" // (class name from node utils)
      ]
    }]; */
		return [{
            library: '@angular/service-worker',
            modules: [
                'SwPush'
            ]
        }];
	}
	/**
	 * @typedef {Object} ServiceVariable
	 * @property {string} name - Name of the variable
	 * @property {string} [type] - Type of the variable
	 * @property {any} [value] - Initial value to assign to the variable
	 */

	/**
	 * @returns {Array<ServiceVariable>}
	 */
	declareVariables() {
		return [];
	}

	generateSnippet(serviceType, serviceClassTemplate) {

		/*Eg for node logic
                                                             (confignode nodeName)
        return `let configObj = this.sdService.getConfigObj('306d616b-3471-2452-0320-bdc8c7eae343', '${this.configId}')
        let listUtil = new sftpUtil();
        await listUtil.listUtilSftp(configObj,${this.remotePath},${this.pattern});
        `;*/
		return ``;
	}

    getListenerSnippet() {
        return `
        try{
            if(this.swPush.isEnabled){
                this.swPush.subscription.subscribe(event=>{
                    let bh = this.sdService.__constructDefault({});
                    ${this.constructorOptions.resultMapping} = event;
                    this.${this.constructorOptions.functionName}(bh);
                });
            } else{
                throw new Error("Service workers are disabled or not supported by this browser");
            }
        } catch(e){
            let bh = this.sdService.__constructDefault({});
            return this.errorHandler(bh, e, '${this.constructorOptions.functionName}');
        }
        `;
    }

	getCallTemplate() {

		/*
        return `this.${this.functionName}(bh);`;
        */
		return '';
	}

	populateConfig(configObj) {
		/*
        this.tlsConfig = configObj['TLS'][this.tlsConfigID];
         */
	}

	/**
	 * reutrn [{name: '', version: ''}]
	 */
	updatePackageJSON() {
		return [];
	}

	// This callback gets the whole service file whose code is being generated as string.
	// Manipulate anything and return the file string back
	// for codegen.Useful in changing `constuctor` options.

    updateTemplate(serviceClassTemplate) {
        // base calss update Template. return as is;
        const injectStr = 'private swPush: SwPush';
        let constructorInit = 'constructor(';
        let injectionArr = this.getAllInjections(serviceClassTemplate); 
        if (injectionArr && !injectionArr.includes(injectStr)) {
            constructorInit = `constructor(${injectStr},`;
        }
        serviceClassTemplate = serviceClassTemplate.replace("constructor(", constructorInit);
        return serviceClassTemplate;
    }

    getAllInjections(serviceClassTemplate) {
        let regx = new RegExp('constructor\(.*\)');
        if (typeof serviceClassTemplate === 'string') {
            let ms = serviceClassTemplate.match(regx);
            if (ms && ms.length) {
                let m = ms[0];
                return m.replace('constructor(', '').replace(')', '').split(',').map(v => v.trim());
            }
        }
        return null;
    }

	// We use `prettier` library to validate your Code snippet returned by generateSnippt with a errorTemplate.
	// Given below is the default error template where your snippet is appended at `//appendnew_node`
	// placeholder comment and then validated by `prettier`.
	// If you wish to change the error template implement this function.

	getErrorTemplate() {
		return `
        export class errorCheck {
                //appendnew_node
        }
        `;
	}
};
