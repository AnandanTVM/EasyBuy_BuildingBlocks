let BaseComponent = require("@jatahworx/bhive-toolkits").BaseComponent;
let statusCodes = require('http-status-codes');

module.exports = class GlobalSession extends BaseComponent {
    constructor(constructorOptions) {
        super(constructorOptions.id, constructorOptions.name, "neutrinos_service_designer_GlobalSession", "GlobalSession");
        this.viewType = BaseComponent.viewTypes.SERVER;
        // express-session options
        // cookie
        this.cookie = {
            domain: constructorOptions.cookieDomain,
            secure: constructorOptions.cookieSecure,
            expires: constructorOptions.cookieExpires,
            httpOnly: constructorOptions.cookieHttpOnly,
            maxAge: constructorOptions.cookieMaxAge,
            path: constructorOptions.cookiePath,
            sameSite: constructorOptions.cookieSameSite
        };
        // name - optional
        // proxy - optional [true, false, undefined]
        this.proxy = constructorOptions.proxy;
        // resave - required [true, false]
        this.resave = constructorOptions.resave;
        // rolling - optional [true, false]
        this.rolling = constructorOptions.rolling;
        // saveUninitialized - required [true, false]
        this.saveUninitialized = constructorOptions.saveUninitialized;
        // secret - required [string]
        this.secret = constructorOptions.secret;
        // store - optional [Database Name | undefined]
        this.dbConnectionName = constructorOptions.dbConnectionName;
        // unset - optional [keep, destroy]
        this.unset = constructorOptions.unset;

        this.errorMapping = constructorOptions.errorMapping;

        if (this.errorMapping && this.errorMapping.status) {
            let statuses = Object.values(statusCodes);
            if (!statuses.includes(this.errorMapping.status)) {
                throw new Error('Response status is not a valid status number.');
            }
        }
        this.nodeType = BaseComponent.nodeTypes.MIDDLEWARE;
    }

    generateImports(rootPaths) {
        return [
            {
                library: 'express-session',
                alias: 'expressSession',
            },
            {
                library: rootPaths.pathToUtilsRoot + '/ndefault-session/Session/SessionStore',
                modules: [
                    'TypeormStore'
                ]
            },
            {
                library: 'typeorm',
                modules: [
                    'getConnection'
                ]
            }
        ]
    }

    generateSnippet() {
		return {
			nodeSnippet: `let sess: expressSession.SessionOptions = {
                ${this.cookie}
                ${this.proxy}
                ${this.resave}
                ${this.rolling}
                ${this.saveUninitialized}
                ${this.secret}
                ${this.unset}
                ${this.__getStoreTemplate()}
            }
			return expressSession(sess);`,
			async: false
		};
    }

    set cookie(cookie) {
       let c = '{';
        if (cookie.domain) {
            c += 'domain: ' + `"${cookie.domain}",`
        }
        if (typeof cookie.secure === 'boolean') {
            c += 'secure: ' + `${cookie.secure},`;
        }
        if (cookie.expires) {
            c += 'expires: ' + `${cookie.expires},`;
        }
        if (typeof cookie.httpOnly === 'boolean') {
            c += 'httpOnly: ' + `${cookie.httpOnly},`;
        }
        if (cookie.path) {
            c += 'path: ' + `"${cookie.path}",`;
        }

        if (cookie.maxAge) {
            c += 'maxAge: ' + `${cookie.maxAge},`;
        }

        if (cookie.sameSite) {
            c += `sameSite: ${cookie.sameSite}`;
        }

        c += '}'
        this.__cookie = c;
    }

    get cookie() {
        if (typeof this.__cookie == 'string' && this.__cookie.length) {
            return `
                cookie: ${this.__cookie},
            `
        }
        return '';
    }

    set proxy (proxy) {
        this.__proxy = proxy;
    }

    get proxy () {
        let v = this.__bool(this.__proxy);
        if (v.length) {
            return `
                proxy: ${v},
            `
        }
        return '';
    }

    set resave (resave) {
        this.__resave = resave;
    }

    get resave() {
        let v = this.__bool(this.__resave);
        if (v.length) {
            return `
                resave: ${v},
            `
        }
        return '';
    }

    set rolling (rolling) {
        this.__rolling = rolling;
    }

    get rolling () {
        let v = this.__bool(this.__rolling);
        if (v.length) {
            return `
                rolling: ${v},
            `
        }
        return '';
    }

    set saveUninitialized(saveUninitailzed) {
        this.__saveUninitialized = saveUninitailzed;
    }

    get saveUninitialized() {
        let v = this.__bool(this.__saveUninitialized);
        if (v.length) {
            return `
             saveUninitialized: ${v},
            `
        }
        return '';
    }

    set secret (secret) {
        this.__secret = secret;
    }

    get secret () {
        if (!this.__secret) throw new Error('Invalid Session options. secret is required.');
        return `
            secret: ${this.__secret},
        `
    }

    set dbConnectionName (dbConnectionName) {
        this.__dbConnectionName = dbConnectionName;
    }

    get dbConnectionName() {
        return this.__dbConnectionName || '';
    }

    __getStoreTemplate () {
        if (!this.dbConnectionName) return '';
        return `
            store: new TypeormStore({
                repository: getConnection('${this.dbConnectionName}').getRepository('Session')
            })
        `
    }

    set unset (unset) {
        this.__unset = unset;
    }

    get unset () {
        if (this.__unset && !['keep', 'destroy'].includes(this.__unset)) throw new Error('Invalid options for global session. unset can only be keep or destroy');
        return `
            unset: '${this.__unset}',
        `
    }

    __bool(b) {
        return typeof b == 'boolean' ? JSON.stringify(b) : '';
    }

    get error() {
        let e = 'throw e;';
        if (this.errorMapping && this.errorMapping.status && this.errorMapping.send) {
            e = 'bh.web.next({ status: ' + this.errorMapping.status + ', send: ' + this.errorMapping.send + ' })';  
        }
        return e;
    }

    getErrorTemplate() {
        return `
        let c = {
            //appendnew_node
        }
        `;
    }
}
