<script type="text/x-red" data-template-name="HttpIn">
<div class="editor-form-row">
	<input type="inputField" id="node-input-name" placeholder="[n-sd]common.label.name">
</div>
<!-- Method(select) -->
<div class="editor-form-row">
    <label for="node-input-method"><span data-i18n="httpin.label.method"></span></label>
    <select id="node-input-method"></select>
</div>

<!-- Path -->
<div class="editor-form-row">
    <input type="inputField" id="node-input-path" placeholder="[n-sd]httpin.placeholder.path" required>
</div>

<!-- Sequence ID(select) -->
<div class="editor-form-row">
    <label for="node-input-sequenceId"><span data-i18n="httpin.label.seqid"></span></label>
    <select id="node-input-sequenceId"></select>
</div>

<div class="editor-form-row" id="accordion">
    <!-- FILE UPLOAD SECTION -->
    <h5 class="pallete-title-underline" id="file-options-header">File Upload</h5>
    <div id="file-upload-content">
        <!-- Accept File Upload(checkbox) -->
        <div class="editor-form-row-margin-bottom-1">
            <input type="checkbox" id="node-input-acceptFileUpload">
        </div>
        <!-- Type(Button Toggle) -->
        <div id="file-upload-options">
            <label for="radiogroup" class="editor-form-row-label"><span data-i18n="httpin.label.dest"></span></label>
            <div class="editor-form-row-margin-bottom-1" id="filetype-radio">
                <input type="inputField" id="node-input-filetype" style="display:none;">
                <input type="radio" name="optionType" value="path" id="filetype-path">
                <label for="filetype-path" data-i18n="common.label.filepath" class="radio-label"></label><br>
                <input type="radio" name="optionType" value="memory" id="filetype-memory">
                <label for="filetype-memory" data-i18n="httpin.label.memory" class="radio-label"></label><br>
            </div>
            <!-- Upload Path(input) -->
            <div class="editor-form-row" id="uploadpath-input-container">
                <input type="typed" id="node-input-typed-uploadpath" style="width: 100%;">
            </div>
            <!-- File Option(Editable List) -->
            <label for="fileoptions-section" class="editor-form-row-label"><span data-i18n="httpin.label.file-options"></span></label>
            <div id="fileoptions-section" class="props-section">
                <div class="add-section editor-form-row">
                    <div class="srd-editableList-add-kv-wrp">
                        <!-- Name(input) -->
                        <input type="inputField" class="property-key" placeholder="[n-sd]common.label.name">
                        <!-- Max CountI(input) -->
                        <input type="inputField" class="property-value" placeholder="[n-sd]httpin.placeholder.max-count">
                    </div>
                </div>
                <div class="properties-container" validatesform="true">
                    <ol id="fileoptions-list"></ol>
                </div>
                <span class="list-keys-invalid">Editable List Invalid Message</span>
            </div>
        </div>
    </div>
    <!-- DOCUMENTATION SECTION -->
    <h5 class="pallete-title-underline" id="documentation-header">Documentation</h5>
    <div id="documentation-content">
        <!-- Summary(input) -->
        <div class="editor-form-row">
            <input type="inputField" id="node-input-summary" placeholder="[n-sd]httpin.placeholder.summary">
        </div>

        <!-- Description(input) -->
        <div class="editor-form-row">
            <input type="inputField" id="node-input-description" placeholder="[n-sd]httpin.placeholder.description">
        </div>
    
        <!-- Parameters(Editable List) -->
        <label for="params-section" class="editor-form-row-label"><span data-i18n="httpin.label.parameters"></span></label>
        <div id="params-section" class="props-section">
            <!-- <div class="add-section"> -->
            <div class="srd-editableList-add-kv-wrp">
                <!-- Name(input) -->
                <input type="inputField" class="property-key" id="key" placeholder="[n-sd]common.label.name">
                <!-- Description(input) -->
                <input type="inputField" class="property-value" id="desc" placeholder="[n-sd]httpin.placeholder.description">
                <!-- Type(select) -->
                <select type="inputField" id="type" placeholder="[n-sd]common.label.type"></select>
                <!-- Required(checkbx) -->
                <input type="checkbox" id="required">
            </div>
            <div class="properties-container" validatesform="true">
                <ol id="params-list"></ol>
            </div>
            <span class="list-keys-invalid">Editable List Invalid Message</span>
        </div>

        <!-- Responses(Editable List) -->
        <label for="responses-section" class="editor-form-row-label"><span data-i18n="httpin.label.responses"></span></label>
        <div id="responses-section" class="props-section">
            <div class="add-section editor-form-row">
                <div class="srd-editableList-add-kv-wrp">
                    <!-- Message(input) -->
                    <input type="inputField" class="property-key" placeholder="[n-sd]httpin.placeholder.message">
                    <!-- Http Code(input) -->
                    <input type="inputField" class="property-value" placeholder="[n-sd]httpin.placeholder.http-code">
                </div>
            </div>
            <div class="properties-container" validatesform="true">
                <ol id="responses-list"></ol>
            </div>
            <span class="list-keys-invalid">Editable List Invalid Message</span>
        </div>

        <!-- Consumes(select) -->
        <label for="consumes-section" class="editor-form-row-label"><span data-i18n="httpin.label.consumes"></span></label>
        <div id="consumes-section" class="props-section editor-form-row add-section">
            <!-- <div class="add-section"> -->
            <div class="srd-editableList-add-kv-wrp">
                <!-- consumptionTypes(input) -->
                <input type="inputField" class="property-value" id="key" placeholder="[n-sd]httpin.placeholder.content-type">
            </div>
            <div class="properties-container" validatesform="true">
                <ol id="consumes-list"></ol>
            </div>
            <span class="list-keys-invalid">Editable List Invalid</span>
        </div>

        <!-- Produces(select) -->
        <label for="produces-section" class="editor-form-row-label"><span data-i18n="httpin.label.produces"></span></label>
        <div id="produces-section" class="props-section editor-form-row">
            <!-- <div class="add-section"> -->
            <div class="srd-editableList-add-kv-wrp">
                <!-- consumptionTypes(input) -->
                <input type="inputField" class="property-value" id="key" placeholder="[n-sd]httpin.placeholder.content-type">
            </div>
            <div class="properties-container" validatesform="true">
                <ol id="produces-list"></ol>
            </div>
            <span class="list-keys-invalid">Editable List Invalid</span>
        </div>
    </div>
</div>
</script>
<script type="text/javascript">
    registerNode({
        nodeType: 'HttpIn',
        serviceType: 'server',
        nodeDef: {
            color: "#35477d",
            shape: "circle",
			category: 'HTTP',
			isClassFunction: false,
            defaults: {
                // input text fields
                name: { value: '' },
                path: { value: '', required: true },
                uploadpath: { value: '' },
                summary: { value: '' },
                description: { value: '' },
                // select fields
                method: { value: '' },
                sequenceId: { value: '' },
                consumes: { value: '' },
                produces: { value: '' },
                filetype: { value: 'path' },
                acceptFileUpload: { value: false },
                // constructed
                httpOptions: { value: {} },
                uploadFileOptions: { value: {} },
                // editableList data
                editableListData: {
                    value: {
                        fileptions: [],
                        responses: [],
                        params: [],
                        consums: [],
                        produces: []
                    }
                },
                // ports
                inputs: { value: 0 },
                outputs: { value: 1 },
            },
            inputs: 0,
            outputs: 1,
            icon: "ndefault-all-nodes/http-in-start-node.svg",
            label: function (SD) {
                let label = 'HTTP In';
                if (this.name) {
                    label = this.name;
                } else if (this.method && this.path) {
                    label = '[' + this.method + ']' + (this.path.startsWith('/') ? this.path : '/' + this.path);
                }
                return label.length > 23 ? label.slice(0, 23) + '...' : label;
            },
            paletteLabel: function () {
                return this.name || 'HTTP In'
			},
			oneditinit: function (SD) {
				const form = $('#dialog-form');
				const typedFieldPrefix = 'node-input-typed-';				
				function osPathConcatenator({ value }, v = '') {
					return `os.${value}() + "` + (!v || value.startsWith('/') ? v : '/' + v) + `"`;
				}
				const typedInputOptions = {
					uploadpath: {
						types: [
                            { value: 'str', label: "string", nullable: true, nullableValue: '' },
                            { value: 'server_env', label: "env", nullable: true, nullableValue: '' },
							{ value: 'homedir', label: 'homedir', generator: osPathConcatenator },
							{ value: 'tmpdir', label: 'tmpdir' , generator: osPathConcatenator }
						]
					}
				}
				form.find('input[type="typed"]').each(function() {
					const inputElm = $(this);
                    const id = inputElm.attr('id');
					$(this).typedInput(id ? typedInputOptions[id.replace(typedFieldPrefix, '')] : null);
				});
			},
            oneditprepare: function (SD) {
                const node = this;
                node._editableListData = { fileoptions: [], responses: [], params: [], produces: [], consumes: [] };
                const form = $('#dialog-form');
                const fieldPrefix = 'node-input-';
                const seqIds = SD.nodes.filterNodes({ type: 'RouteMiddlewareStart' }).map(node => ({ displayValue: node.name, value: node.name }));
                const methods = [
                    { value: 'get', displayValue: 'GET' },
                    { value: 'post', displayValue: 'POST' },
                    { value: 'put', displayValue: 'PUT' },
                    { value: 'delete', displayValue: 'DELETE' },
                    { value: 'patch', displayValue: 'PATCH' },
                ];
                const consumptionTypes = productionTypes = [
                    { value: 'application/json', displayValue: 'JSON' },
                    { value: 'application/text', displayValue: 'TEXT' },
                    { value: 'application/blob', displayValue: 'BLOB' },
                    { value: 'application/arraybuffer', displayValue: 'ARRAY BUFFER' },
                ]
                const filetypes = [
                    { value: 'memory', displayValue: 'Memory' },
                    { value: 'path', displayValue: 'Path' }
                ]
                const paramsTypes = [
                    { value: 'query', displayValue: 'query' },
                    { value: 'path', displayValue: 'path' },
                    { value: 'body', displayValue: 'body' }
                ]
                const selectOptions = {
                    method: {
                        optionsData: methods,
                        value: node.method
                    },
                    sequenceId: {
                        optionsData: [...seqIds, { value: '', displayValue: 'None' }],
                        value: node.sequenceId,
                        placeholder: 'Select A Middleware Sequence'
                    },
                    filetype: {
                        optionsData: filetypes,
                        value: node.filetype
                    },
                    consumes: {
                        optionsData: consumptionTypes,
                        value: node.consumes
                    },
                    produces: {
                        optionsData: productionTypes,
                        value: node.produces
                    },
                    type: {
                        optionsData: paramsTypes,
                        placeholder: 'Select parameter type'
                    }
                };
                const inputOptions = {
                    path: {
                        validateOnCreate: true,
						noformvalidation: false
                    }
                }
                form.find('input[type="inputField"]').each(function () {
                    const inputElm = $(this);
                    const id = inputElm.attr('id');
                    inputElm.inputField(id ? inputOptions[id.replace(fieldPrefix, '')] : null);
                });
                form.find('#node-input-acceptFileUpload').toggleButton({
                    label: SD._('n-sd:httpin.label.upload'),
                    afterToggle: function (checked) {
                        hideOrShowFilesUploadOptions(!checked)
                    }
                });
                form.find('select').each(function () {
                    selectElm = $(this);
                    const field = selectElm.attr('id').replace(fieldPrefix, '');
                    selectElm.selectField(selectOptions[field]);
                });
                function updateEditableListData(prop, val, currentRowIdArr, section) {
                    const i = node._editableListData[section].findIndex(element => currentRowIdArr === element['rowId']);
                    node._editableListData[section][i][prop] = val;
                    return i;
                }

                function validate(checkUnique, section, editableList) {
                    SD.defaults.validateForm(SD.validators.editableList(editableList.closest('.properties-container'), editableList, {
                        checkUniquenessOn: checkUnique && node._editableListData[section].map(x => x.key),
                        checkValidityOn: node._editableListData[section],
                        errorMsgContainer: $(`#${section}-section span.list-keys-invalid`)
                    }));
                }

                function updations(prop, elemData, inputVal, container, section, checkUnique) {
                    let index = updateEditableListData(prop, inputVal, container.data().data.rowData.rowId, section);
                    node._editableListData[section][index].valid = elemData ? elemData.valid : node._editableListData[section][index].valid;
                    container.data('data', { rowData: node._editableListData[section][index] });
                    validate(checkUnique, section, $(`#${section}-section ol`));
                }

                function createEditableListHeaders(headerTitles, propertiesContainer) {
                    if (headerTitles instanceof Array && headerTitles.length) {
                        const propertiesHeaderContainer = $(`<div class="properties-header-container"></div>`).prependTo(propertiesContainer);
                        headerTitles.forEach((header, i) => {
                            const style = header.style || '';
                            const classList = `editableList-header ${header.classList || ''}`
                            propertiesHeaderContainer.append(`<div class="${classList}" style="${style}">${header.title}</div>`);
                        });
                    }
                }

                function onItemRemoved(data, sectionType, propertiesContainer, checkUnique) {
                    node._editableListData[sectionType] = node._editableListData[sectionType].filter(vObj => vObj['rowId'] !== data.rowData.rowId);
                    validate(checkUnique, sectionType, propertiesContainer);
                    if (node._editableListData[sectionType].length === 0) {
                        propertiesContainer.hide();
                    }
                }

                function prepareEditableList(sectionType, headerTitles = [], checkUnique = true) {
                    /* Properties add section key-value fields */
                    const keyField = $(`#${sectionType}-section .property-key`).inputField('option', 'validatorRegexp', SD.validators.patterns.noblank);
                    const valueField = $(`#${sectionType}-section .property-value`).inputField('option', 'validator', function (v) {
                        if (!SD.validators.patterns.number.test(v)) {
                            return {
                                valid: false,
                                errorMessage: 'Value should be a number.'
                            }
                        }
                        return {
                            valid: true
                        }
                    });

                    /* Properties List */
                    const propertiesContainer = $(`#${sectionType}-section .properties-container`);
                    const invalidListMsg = $(`#${sectionType}-section .list-keys-invalid`);

                    createEditableListHeaders(headerTitles, propertiesContainer);

                    const editableList = $(`#${sectionType}-list`).data({ valid: true, isUnique: true, isValid: true });
                    editableList.editableList({
                        addItem: function (container, i, data) {
                            const rowData = data.rowData || {};

                            /* property list's "key" field */
                            const listKey = $(`<input type="inputField" class="property-key"/>`).appendTo(container).inputField({
                                wrapperAttr: { style: 'width: 40%;' },
                                validatorRegexp: SD.validators.patterns.noblank,
                                value: rowData.key || keyField.val(),
                                updations: function (elemData, inputVal) {
                                    updations('key', {valid: listKey.inputField('valid') && listVal.inputField('valid') }, inputVal, container, sectionType, checkUnique);
                                }
                            });

                            const listVal = $(`<input type="inputField" class="property-value"/>`).appendTo(container).inputField({
                                wrapperAttr: { style: 'width: 40%;' },
                                validatorRegexp: SD.validators.patterns.number,
                                value: rowData.value || valueField.val(),
                                updations: function (elemData, inputVal) {
                                    updations('value', {valid: listKey.inputField('valid') && listVal.inputField('valid') }, inputVal, container, sectionType, checkUnique);
                                }
                            });

                            const dataObj = {
                                key: listKey.val(),
                                value: listVal.val(),
                                rowId: rowData.rowId || SD.nodes.id(),
                                valid: true
                            };

                            node._editableListData[sectionType].push(dataObj);
                            propertiesContainer.show();
                            container.attr('id', dataObj.rowId).data('data', { rowData: dataObj });

                            /* Clear the "Add" Section input fields */
                            keyField.inputField('reset');
                            valueField.inputField('reset');
                        },
                        showAddBtnLabel: false,
                        removable: true,
                        scrollOnAdd: true,
                        removeItem: function (data) {
                            onItemRemoved(data, sectionType, propertiesContainer, checkUnique)
                        },
                        validator: function () {
                            if (!keyField.inputField('valid')) {
                                SD.dialogService.openSnackBar('Invalid key. Key should contain atleast one character.');
                                return false;
                            }
                            if (!valueField.inputField('valid')) {
                                SD.dialogService.openSnackBar('Invalid value. Value should be numerical value.');
                                return false;
                            }
                            if (checkUnique && node._editableListData[sectionType].find(vObj => vObj['key'] === keyField.val())) {
                                SD.dialogService.openSnackBar('Duplicate key. This key already exists.');
                                return false
                            }
                            return true;
                        }
                    });
                    $(`#${sectionType}-section .add-prop-btn-wrp`).insertAfter($(`#${sectionType}-section .srd-editableList-add-kv-wrp`));
                    if (!editableList.editableList('items').length) {
                        propertiesContainer.hide();
                    }
                }
                const fileOptionHeaders = [
                    { title: SD._('common.label.name'), style: 'left: 9.5%;' },
                    { title: SD._('n-sd:httpin.placeholder.max-count'), style: 'left: 50%' }
                ];
                const responsesHeaders = [
                    { title: SD._('n-sd:httpin.placeholder.message'), style: 'left: 9.5%' },
                    { title: SD._('n-sd:httpin.placeholder.http-code'), style: 'left: 50%' }
                ]
                const paramsHeaders = [
                    { title: SD._('common.label.name'), style: 'left: 8.5%' },
                    { title: SD._('n-sd:httpin.placeholder.description'), style: 'left: 36.5%' },
                    { title: SD._('n-sd:common.label.type'), style: 'left: 64.5%' }
                ]
                const contentTypeHeaders = [
                    { title: SD._('n-sd:httpin.placeholder.content-type'), style: 'left: 8.5%' }
                ]
                prepareEditableList('fileoptions', fileOptionHeaders);
                prepareEditableList('responses', responsesHeaders, false);

                /* docs => parameters */
                function prepareDocsEditableList(section, listHeaders, requiredFieldLabels) {
                    const input = form.find(`#${section}-section .srd-editableList-add-kv-wrp input[type="inputField"]`).inputField('option', {
                        validatorRegexp: SD.validators.patterns.noblank,
                        wrapperAttr: {
                            style: 'width: 100%'
                        }
                    });
                    const select = form.find(`#${section}-section .srd-editableList-add-kv-wrp select`);
                    const toggle = form.find(`#${section}-section .srd-editableList-add-kv-wrp input[type="checkbox"]`).toggleButton({
                        label: 'Required',
                        cssObject: {
                            'margin-top': '1em'
                        }
                    });

                    const listContainer = form.find(`#${section}-list`).parent();
                    createEditableListHeaders(listHeaders, listContainer);
                    form.find(`#${section}-list`).data({ valid: true, isUnique: true, isValid: true }).editableList({
                        addItem: function (container, i, data) {
                            let added = false;
                            const rowData = data.rowData || {};
                            let dataObj = {};
                            input.each(function () {
                                const inputElm = $(this);
                                const rowItem = $(`<input type="inputField" class="property-value" inputField/>`).appendTo(container).inputField({
                                    validatorRegexp: SD.validators.patterns.noblank,
                                    value: rowData[inputElm.attr('id')] || inputElm.val(),
                                    updations: function (elemData, inputVal) {
                                        if (added) {
											let valid = true;
											container.find('[inputField]') .each(function() {
												valid = valid && $(this).inputField('valid');
											});
                                            updations(inputElm.attr('id'), { valid }, inputVal, container, section, true);
                                        }
                                    }
                                });
                                dataObj[inputElm.attr('id')] = rowItem.val();
                            })
                            select.each(function () {
                                const selectElm = $(this);
                                const rowItem = $(`<select class="property-value"></select>`).appendTo(container).selectField({
                                    optionsData: paramsTypes,
                                    value: rowData[selectElm.attr('id')] || selectElm.selectField('selected'),
                                    change: function (val) {
                                        if (added) {
                                            updations(selectElm.attr('id'), null, val, container, section, true);
                                        }
                                    }
                                });
                                dataObj[selectElm.attr('id')] = rowItem.selectField('selected');
                            })
                            toggle.each(function () {
                                const toggleElm = $(this);
                                const checked = rowData[toggleElm.attr('id')] === undefined ? toggle.toggleButton('state') : rowData[toggleElm.attr('id')]
                                const rowItem = $(`<input type="checkbox" class="property-value" ${checked ? 'checked' : ''}>`).appendTo(container).toggleButton({
                                    afterToggle: function (val, e) {
                                        if (added) {
                                            updations(toggleElm.attr('id'), null, val, container, section, true);
                                        }
                                    }
                                });
                                dataObj[toggleElm.attr('id')] = rowItem.toggleButton('state');
                            });
                            dataObj = {
                                ...dataObj,
                                rowId: rowData.rowId || SD.nodes.id(),
                                valid: true
                            };
                            node._editableListData[section].push(dataObj);
                            listContainer.show();
                            container.attr('id', dataObj.rowId).data('data', { rowData: dataObj });
                            added = true;
                            input.inputField('reset');
                            select.selectField('clearSelection');
                        },
                        removable: true,
                        scrollOnAdd: true,
                        removeItem: function (data) {
                            onItemRemoved(data, section, listContainer, true);
                        },
						validator: function () {
							if (![...input].every((elm) => $(elm).inputField('valid'))) {
								const moreThanOneField = requiredFieldLabels.length > 1 || '';
								let errMsg = 'Fields can not be empty';
								if (Array.isArray(requiredFieldLabels) && requiredFieldLabels.length) {
									errMsg = requiredFieldLabels.reduce((p, c, i, a) => {
										p += `${moreThanOneField && i === a.length - 1 ? ' and' : ' '} "${c}"`;
										return p;
									}, '') + ` field${moreThanOneField && 's'} can not be empty`;
								}
								SD.dialogService.openSnackBar(errMsg);
								return false;
							}
							if (![...select].every((elm) => $(elm).selectField('selected'))) {
								SD.dialogService.openSnackBar('Select parameter type');
								return false;
							}
							if (node._editableListData[section].find(vObj => vObj['key'] === input.val())) {
								SD.dialogService.openSnackBar('Duplicate value.');
								return false;
							}
							return true;
						}
					});
                    form.find(`#${section}-section .add-prop-btn-wrp`).insertAfter(`#${section}-section .srd-editableList-add-kv-wrp`);
                    listContainer.hide();
                }
                prepareDocsEditableList('params', paramsHeaders, ["Name", "Description"]);
                prepareDocsEditableList('consumes', contentTypeHeaders, ["Content Type"]);
                prepareDocsEditableList('produces', contentTypeHeaders, ["Content Type"]);

                function populateExistingVariables(sectionName) {
                    const list = form.find(`#${sectionName}-list`)
                    if (node.editableListData[sectionName] && node.editableListData[sectionName] instanceof Array) {
                        for (let row of node.editableListData[sectionName])
                            list.editableList('addItem', { rowData: row, validator: false });
                    }
                }

                function hideOrShowFilesUploadOptions(hide) {
                    if (!hide) {
                        form.find('#file-upload-options').show();
                    } else {
                        form.find('#file-upload-options').hide();
                    }
                }

                if (!node.acceptFileUpload) {
                    $('#node-input-typed-uploadpath').typedInput('value', '');
                }

                Object.keys(node.editableListData).forEach(section => {
                    populateExistingVariables(section);
                })

                hideOrShowFilesUploadOptions(!node.acceptFileUpload || node.acceptFileUpload === 'false');
                form.find('#node-input-filetype').change(function () {
                    form.find(`#filetype-radio input[value="${$(this).val()}"]`).prop('checked', true);
                    if ($(this).val() === 'path') {
                        form.find('#node-input-typed-uploadpath').typedInput('show');
                    } else {
                        form.find('#node-input-typed-uploadpath').typedInput('hide');
                    }
                })
                form.find('#filetype-radio input[type="radio"]').change(function () {
                    storageType = form.find('#filetype-radio input[type="radio"]:checked').val();
                    $('#node-input-filetype').val(storageType);
                    if (storageType === 'path') {
                        form.find('#node-input-typed-uploadpath').typedInput('show');
                    } else {
                        form.find('#node-input-typed-uploadpath').typedInput('hide');
                    }
                })

            },
            oneditsave: function (SD) {
                const node = this;
                const form = $('#dialog-form');
                const responses = node._editableListData.responses.reduce((obj, codeDescObj) => {
                    obj[codeDescObj.value] = {
                        'description': codeDescObj.key
                    }
                    return obj;
                }, {});
                const httpOptionsObj = {
                    [form.find('#node-input-path').val()]: {
                        [form.find('#node-input-method').val()]: {
                            "summary": form.find('#node-input-summary').val(),
                            "description": form.find('#node-input-description').val(),
                            "consumes": node._editableListData.consumes.map(i => i.key),
                            "produces": node._editableListData.produces.map(i => i.key),
                            // construct "parameters" array from node._editableListData
                            "parameters": node._editableListData.params.map(param => ({
                                in: param.type,
                                name: param.key,
                                description: param.desc,
                                required: param.required
                            })),
                            "responses": responses
                        }
                    }
                };

                if ($('#node-input-acceptFileUpload').toggleButton('state')) {
                    const uploadFileOptions = {
                        "type": form.find('#node-input-filetype').val(),
                        "fileOptions": node._editableListData.fileoptions.map((option) => ({ name: option.key, maxCount: parseInt(option.value) }))
                    }
                    node.uploadFileOptions = uploadFileOptions;
                } else {
                    delete node.uploadFileOptions;
                    delete node._editableListData.fileoptions;
                }
                if ($('#node-input-filetype').val() === 'memory') {
                    $('#node-input-uploadpath').val('');
                } else if(node.uploadFileOptions) {
                    const uploadPathDOM = form.find('#node-input-typed-uploadpath');
                    let path = uploadPathDOM.typedInput('generate');
                    if(!path) {
                        path = SD.utils.getValueFromTypedInput({type: uploadPathDOM.typedInput('type'), value: uploadPathDOM.typedInput('value'), nullable: true, nullableValue: ""});
                    }
                    node.uploadFileOptions.path = path
                }

                node.httpOptions = httpOptionsObj;
                node.editableListData = JSON.parse(JSON.stringify(node._editableListData));
                delete node._editableListData;
            },
            oneditcancel: function () {
                delete this._editableListData;
            },
            docsLink: 'http-in'
        }
    });
</script>