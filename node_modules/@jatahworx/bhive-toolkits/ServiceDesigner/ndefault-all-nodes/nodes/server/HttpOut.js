let BaseComponent = require("@jatahworx/bhive-toolkits").BaseComponent;
let statusCodes = require('http-status-codes');
let util = require("@jatahworx/bhive-toolkits").SRDCodeGenUtil;

/**
 * http-end:
 * 1. Response: Send - file | txt | JSON
 * 2. Go to next() post middleware
 * 3. If user wants to set data for evaluating in the
 * next post-middleware, he will use scrip node to
 * set res.data.a = 'some value';
 */
module.exports = class HttpOut extends BaseComponent {
    /**
     *Creates an instance of HttpOut.
     * @param {*} constructorOptions
     * constructorOptions.responseType: bin | obj | txt | file
     * constructorOptions.responseMapping: response type and status code
     *      Based on responseType
     *          bin: { bin: bh.web.res.body, status: 200}
     *          send: { send: bh.web.res.body, status: 200}
     *          send: { sendFile: '/filepath', status: 200}
     * constructorOptions.headers: Custom response headers
     *      {'Bearer token': bh.web.res.generatedToken, 'Content-Type': 'application/json'}
     * constructorOptions.cookies: Custom response cookies
     */
    constructor(constructorOptions) {
        super(constructorOptions.id, constructorOptions.name, "neutrinos_service_designer_HttpOut", "HttpOut");

        this.nodeOptions = constructorOptions;
        this.viewType = 'server';
    }

    init(constructorOptions) {
        this.__types = ['bin', 'obj', 'txt', 'next', 'redirect', 'stream', 'file'];
        this.getTypedValue = (new util()).getValueFromTypedInput;

        // bin || obj || txt
        this.responseType = constructorOptions.responseType;
        this.responseMapping = constructorOptions.responseMapping;
        if (this.responseType != 'next' && typeof this.responseMapping != 'string' && typeof this.responseMapping != 'object') {
            throw new Error('responseMapping is either missing or invalid');
        }

        if (this.responseType !== 'next' &&
            this.responseMapping && typeof this.responseMapping == 'object' &&
            ((this.responseType == 'bin' && !this.responseMapping[this.responseType]) || (this.responseType == 'file' && !this.responseMapping[this.responseType]) ||
                ((this.responseType == 'txt' || this.responseType == 'obj') && !this.responseMapping.send))) {
            throw new Error(`Response should have status of type 'number' and a property 'bin' (for responseType 'bin') or property send with a bh mapping, obj or txt.`)
        }

        if (this.responseMapping && this.responseMapping.status && typeof this.responseMapping.status == 'number') {
            let statuses = Object.values(statusCodes);
            if (!statuses.includes(this.responseMapping.status)) {
                throw new Error('Response status is not a valid status number.');
            }
        }

        this.headers = constructorOptions.headers;
        this.cookies = constructorOptions.cookies;

    }
    set responseType(responseType) {
        if (this.__types.includes(responseType)) {
            this._responseType = responseType;
        }
        else {
            throw new Error('response type can only be bin or obj or txt');
        }
    }

    get responseType() {
        return this._responseType;
    }

    /**
     * It's such that user can put multiple http-end nodes for different
     * kinds of responses, handling success of each case:
     * bin, txt, json
     */
    generateSnippet() {
        this.init(this.nodeOptions);
        let successResponse = '';

        if (this.responseType == 'bin') {
            successResponse = `
            const readable = new Readable()
            readable._read = () => {} // _read is required but you can noop it
            // setting buffer
            readable.push(${this.responseMapping.bin})
            readable.push(null)
            // setting status
            bh.web.res.status(${this.responseMapping.status})
            readable.pipe(bh.web.res);
            bh.readable = readable;
            `;
        } else if (this.responseType == 'stream') {
            successResponse = `
            ${this.responseMapping.stream}.pipe(bh.web.res);
            `;
        } else if (this.responseType == 'txt') {
            successResponse = `
            bh.web.res.status(${this.responseMapping.status}).send(${this.responseMapping.send})
            `;
        } else if (this.responseType == 'obj') {
            successResponse = `
            bh.web.res.status(${this.responseMapping.status}).send(${this.responseMapping.send})
            `;
        } else if (this.responseType === 'redirect') {
            successResponse = `
            bh.web.res.redirect(${this.responseMapping.status}, ${this.responseMapping[this.responseType]})
            `;
        } 
        else if(this.responseType == 'file'){
            successResponse = `
            bh.web.res.status(${this.responseMapping.status}).download(${this.responseMapping.file})
            `;

        }
        else {
            successResponse = `
             bh.web.next();
            `;
        }
        /**
         * reponseMapping: { status: HTTP_STATUS_CODE[, bin: bh.local.body, send: 'text']}
         */
		return {
			nodeSnippet: `${this.headers}${this.cookies}
			${successResponse};`,
			appendNextNodePlaceholder: false
		};
	}
	
	getCallTemplate() {
        return `await this.${this.nodeOptions.functionName}(bh);`;
    }

	/**
     * headers: {
     *   'Content-Type': 'application/json'
     * }
     * Note: To set run-time headers, use
     * script nodes. Example: bh.web.res.headers({
     *  'session-id': generatedSession()
     * })
     */
    set headers(h) {
        this.__responseHeaders = null;
        if (h) {
            if (!h.ssd_typedInputField) {
                let v = Object.values(h);
                for (let i = 0; i < v.length; i++) {
                    if (typeof v[i] != 'string') {
                        throw new Error('Invalid header key-value: ' + i + ': ' + v[i]);
                    }
                }
                this.__responseHeaders = h;
            } else if (h.ssd_typedInputField) {
                this.__responseHeaders = this.getTypedValue(h);
            }
        }
    }

    // generates: bh.web.res.set(bh.res.data.headers) || bh.web.res.set({'Content-Type': 'application/json'})
    // user should be able to map - 
    get headers() {
        if (typeof this.__responseHeaders === 'object' && Object.keys(this.__responseHeaders).length) {
            return '\nbh.web.res.set(' + JSON.stringify(this.__responseHeaders) + ')';
        }
        if (typeof this.__responseHeaders === 'string') {
            return '\nbh.web.res.set(' + this.__responseHeaders + ')';
        }
        return '';
    }

    // TODO: @paulthomas0 - Support for signed cookies
    // https://expressjs.com/en/4x/api.html#req.signedCookies
    set cookies(c) {
        this.__responseCookies = '\n';
        if (c instanceof Array) {
            for (let i = 0; i < c.length; i++) {
                if (!c[i].name || !c[i].value) {
                    throw new Error('Cookie name - value missing');
                }
                this.__responseCookies += 'bh.web.res.cookie(' + JSON.stringify(c[i].name) + ',' + this.getTypedValue(c[i].value);
                let options = c[i].options;
                if (options && (options = Object.keys(c[i].options))) {
                    let oString = '{';
                    for (let cookieOption of options) {
                        oString += `${cookieOption}: ${c[i].options[cookieOption]},`
                    }
                    oString += '}';
                    this.__responseCookies += ',' + oString;
                }
                this.__responseCookies += ');';
            }
        } else if (c && c.ssd_typedInputField) {
            this.__responseCookies += `bh = this.sdService.cookieSetter(bh, ${this.getTypedValue(c)})`;
        }
    }

    get cookies() {
        return this.__responseCookies ? this.__responseCookies : '';
    }

    set responseMapping(responseMappingObj) {
        this.__responseMapping = responseMappingObj;
        if (this.__responseMapping[this.responseType] && this.__responseMapping[this.responseType].ssd_typedInputField) {
            this.__responseMapping[this.responseType] = this.getTypedValue(responseMappingObj[this.responseType]);
        }
        if (this.__responseMapping.status && this.__responseMapping.status.ssd_typedInputField) {
            this.__responseMapping.status = this.getTypedValue(this.__responseMapping.status);
        }
        if (this.__responseMapping.send && this.__responseMapping.send.ssd_typedInputField) {
            this.__responseMapping.send = this.getTypedValue(responseMappingObj.send);
        }
    }

    get responseMapping() {
        return this.__responseMapping;
    }

    set httpcode(httpcode) {
        this.__httpcode = httpcode;
    }

    get httpcode() {
        return this.__httpcode;
    }
};

/**
 * Example:
 *   {
        "id": "EndingTheHttpRequest",
        "type": "HttpOut",
        "wires": [
            []
        ],
        "responseType": "bin",
        "headers": {
            "Content-Type": "application/octet-stream"
        },
        "cookies": [{
        	"name": "Value1",
        	"value": "Value1",
        	"options": {
        		"httpOnly": true
        	}
        }],
        "responseMapping": {
        	"status": 200,
        	"bin": "bh.local.body"
        }
    }
 */