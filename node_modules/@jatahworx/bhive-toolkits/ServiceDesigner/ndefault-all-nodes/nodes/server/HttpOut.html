<script type="text/x-red" data-template-name="HttpOut">
    <!-- Response Type(select) -->
<div class="editor-form-row">
    <label for="node-input-responseType"><span data-i18n="http-out.label.responseType"></span></label>
    <select type="text" id="node-input-responseType"></select>
</div>
<!-- Http Status(input) -->
<div class="editor-form-row-margin-bottom-0">
    <label for="node-typedInput-httpcode"><span data-i18n="http-out.placeholder.http-code"></span></label>
    <input type="text" id="node-typedInput-httpcode" ui-element-type="typedInput" style="width: 100%;">
    <div class="error-msg-container">
        <span id="invalid-httpcode-error" class="invalid-select display-none">Invalid Status code</span>
    </div>
</div>
<!-- Response Body(typedInput) -->
<div class="editor-form-row">
    <label for="node-typedInput-responseBody"><span>Response Body</span></label>
    <!-- typedInput -->
    <input type="text" id="node-typedInput-responseBody" ui-element-type="typedInput" style="width:100%">
</div>

<!-- Headers(typedInput<=>editableList) -->
<div class="editor-form-row httpout-headers">
    <label for="headers-section"><span>Headers</span>
        <button id="headers-switch"></button>
    </label>
    <div id="headers-section" class="props-section">
        <div id="editableList-headers">
            <div class="srd-editableList-add-kv-wrp">
                <!-- key(input) -->
                <input type="text" class="property-value" editable-list-field="key"
                    placeholder="[n-sd]common.label.key">
                <!-- value(input) -->
                <input type="text" class="property-value" editable-list-field="value"
                    placeholder="[n-sd]common.label.value">
            </div>
            <div class="properties-container" validatesform="true">
                <ol id="headers-list"></ol>
            </div>
            <span class="list-keys-invalid">Editable List Invalid</span>
        </div>
        <div id="typedInput-headers" class="editor-form-row">
            <input type="text" ui-element-type="typedInput" id="node-typedInput-headers" style="width:100%">
        </div>
    </div>
</div>
<!-- Cookies(List(editableList) <=> typedInput) -->
<div id="cookies-container" class="editor-form-row">
    <div class="editor-form-row-label" style="margin-bottom: 1em;"><span data-i18n="common.label.cookies-title"></span>
        <button type="button" class="map-button-wrp" id="cookies-add" title="Add Cookie">
            <image class="map-button" src="assets/serviceDesigner/add-node-kv.svg"></image>
        </button>
        <button type="button" id="cookies-switch"></button>
    </div>
    <div id="editableList-cookies" class="props-section" style="margin-top:1em">

    </div>
    <div id="typedInput-cookies">
        <input type="text" ui-element-type="typedInput" id="node-typedInput-cookies" style="width:100%">
    </div>
</div>

</script>
<script type="text/javascript">
    registerNode({
        nodeType: 'HttpOut',
        serviceType: 'server',
        nodeDef: {
            color: "#d3d312",
            category: 'HTTP',
            defaults: {
                // input text fields
                name: { value: '' },
                // headers
                headers: {
                    value: {
                        type: 'bh',
                        value: ''
                    }
                },
                // response body
                responseBody: {
                    value: {
                        type: 'bh',
                        value: ''
                    },
                    validate: function (v) {
                        return this.responseType === 'next' || server.validators.patterns.noblank.test(v.value);
                    }
                },
                httpcode: {
                    value: {
                        type: 'num',
                        value: ''
                    },
                    validate: function (v) {
                        if (v.type == 'num') {
                            return this.responseType === 'next' || server.utils.isValidHttpStatusCode(v.value);
                        }
                        else {
                            return this.responseType === 'next' || server.validators.patterns.noblank.test(v.value);
                        }
                    }
                },
                responseType: { value: 'obj', required: true },
                responseMapping: { value: '', },
                cookies: { value: [] },
                // ports
                inputs: { value: 1 },
                outputs: { value: 0 },
                editableListData: {
                    value: {
                        headers: [],
                    }
                },
                cookiesList: {
                    value: {}
                },
                switchStates: {
                    value: {
                        headers: 'Map',
                        cookies: 'Map'
                    }
                }
            },
            inputs: 1,
            outputs: 0,
            icon: "ndefault-all-nodes/http-out-node.svg",
            label: function (SD) {
                return this.name || 'HTTP Out';
            },
            paletteLabel: 'HTTP Out',
            oneditinit: function (SD) {
                const node = this;
                const form = $('#dialog-form');
                let __$ = form.find.bind(form);
                const fieldIdPrefix = 'node-input-';
                node._editableListData = {};
                let editorPrepared = false;
                let previousResponseType = node['responseType'];
                const bhtypes = [
                    { value: 'bh', label: 'bh.', validate: SD.validators.typedInput('bh', true) },
                    { value: 'bh.input', label: 'bh.input.', validate: SD.validators.typedInput('bh.input', true) },
                    { value: 'bh.local', label: 'bh.local.', validate: SD.validators.typedInput('bh.local', true) },
                ]

                const strtype = { value: 'str', label: 'string', validate: SD.validators.patterns.noblank };
                const literalType = { value: 'literal', label: 'as is', validate: SD.validators.patterns.noblank };
                const options = {
                    responseType: {
                        optionsData: [
                            { value: 'obj', displayValue: 'JSON' },
                            { value: 'bin', displayValue: 'Binary buffer' },
                            { value: 'stream', displayValue: 'Stream' },
                            { value: 'txt', displayValue: 'Plain text' },
                            { value: 'file', displayValue: 'Send File' },
                            { value: 'next', displayValue: 'Next Middleware' },
                            { value: 'redirect', displayValue: 'Redirect' }
                        ],
                        value: node['responseType'],
                        change: function (val) {
                            if (val === 'next') {
                                hideTypedInput('node-typedInput-httpcode');
                                hideTypedInput('node-typedInput-responseBody');
                            } else {
                                if (val === 'redirect') {
                                    if (!__$('#node-typedInput-httpcode').val()) {
                                        __$('#node-typedInput-httpcode').typedInput('value', 302)
                                    }
                                    __$('[for="node-typedInput-responseBody"]').text('Redirect URL');
                                }
                                else if (val === 'file') {
                                    __$('[for="node-typedInput-responseBody"]').text('File Path');
                                }
                                else {
                                    __$('[for="node-typedInput-responseBody"]').text('Response Body');
                                }
                                showTypedInput('node-typedInput-httpcode');
                                showTypedInput('node-typedInput-responseBody');
                            }
                            if ((previousResponseType !== 'redirect' && val === 'redirect') || (previousResponseType === 'redirect' && val !== 'redirect')) {
                                __$('#node-typedInput-responseBody').typedInput('value', '');
                            }
                            previousResponseType = val;
                            validateForm();
                        }
                    },
                    cookies: [
                        { value: 'domain', displayValue: 'Domain name' },
                        { value: 'expires', displayValue: 'Expiry date' },
                        { value: 'httpOnly', displayValue: 'Http only' },
                        { value: 'maxAge', displayValue: 'Maximum age' },
                        { value: 'path', displayValue: 'Path' },
                        { value: 'secure', displayValue: 'Secure' },
                        { value: 'signed', displayValue: 'Signed' },
                        { value: 'sameSite', displayValue: 'Same Site' }
                    ]
                }
                function showTypedInput(id) {
                    __$('#' + id).parent().show();
                    __$('#' + id).typedInput('show');
                }
                function hideTypedInput(id) {
                    __$('#' + id).parent().hide();
                }
                const stateToFieldMapObj = function (section) {
                    return {
                        Map: {
                            selector: '#editableList-' + section,
                            src: 'assets/serviceDesigner/refresh.svg'
                        },
                        Value: {
                            selector: '#typedInput-' + section,
                            src: 'assets/serviceDesigner/edit.svg'
                        }
                    }
                };

                function validateStatusCode(value) {
                    let isValid = SD.utils.isValidHttpStatusCode(Number(value));
                    if (!isValid) {
                        __$("#invalid-httpcode-error").removeClass('display-none');
                    }
                    else {
                        __$("#invalid-httpcode-error").addClass('display-none');
                    }
                    return isValid;
                }

                function validHttpCodeNForm(type, value, valid) {
                    if (type !== "num" && !__$("#invalid-httpcode-error")[0].classList.contains('display-none')) {
                        __$("#invalid-httpcode-error").addClass('display-none');
                    }
                    validateForm();
                }

                let commonTypes = [...bhtypes, strtype, literalType];
                const requiredFields = Object.keys(node._def.defaults).filter(k => node._def.defaults[k].required);

                const typedInputVars = {
                    types: {
                        responseBody: commonTypes,
                        headers: commonTypes,
                        cookies: commonTypes,
                        httpcode: [...bhtypes, { value: "num", label: 'number', validate: validateStatusCode }]
                    },
                    default: {
                        responseBody: node.responseBody ? node.responseBody.type : 'bh',
                        headers: node.headers ? node.headers.type : 'bh',
                        cookies: node.cookies ? node.cookies.type : 'bh',
                        httpcode: node.httpcode ? node.httpcode.type : 'num'
                    },
                    change: {
                        responseBody: validateForm,
                        headers: validateForm,
                        cookies: validateForm,
                        httpcode: validHttpCodeNForm
                    }
                }

                __$('input[type="text"]').each(function (i) {
                    const elm = $(this);
                    if (elm.attr('ui-element-type') === 'typedInput') {
                        const field = elm.attr('id').replace('node-typedInput-', '')
                        elm.typedInput({
                            noformvalidation: false,
                            types: typedInputVars.types[field],
                            default: typedInputVars.default[field],
                            onvalchanged: function (type, value, valid) {
                                validateForm();
                            },
                            change: typedInputVars.change[field]
                        }).typedInput('value', node[field] ? node[field].value : '')
                    } else if (elm.attr('editable-list-field')) {
                        elm.inputField({
                            noformvalidation: false,
                            validatorRegexp: SD.validators.patterns.noblank,
                            wrapperAttr: { style: ' margin-right: 3%' }
                        });
                    }
                });
                __$('#node-input-name').inputField();

                __$('select').each(function () {
                    const elm = $(this).attr('style', 'width: 100%');
                    const type = elm.attr('id') ? elm.attr('id').replace(fieldIdPrefix, '') : '';
                    elm.selectField(options[type]);
                });
                __$('[editable-list-field]').inputField()

                function validateForm() {
                    SD.defaults.validateForm(true);
                }

                function validate(editableList, section) {
                    SD.defaults.validateForm(SD.validators.editableList(editableList.closest('.properties-container'), editableList, {
                        checkUniquenessOn: node._editableListData[section].map(x => x.key),
                        checkValidityOn: node._editableListData[section],
                        errorMsgContainer: __$(`#${section}-section span.list-keys-invalid`)
                    }));
                }


                function createEditableListHeaders(headerTitles, listContainer) {
                    if (headerTitles instanceof Array && headerTitles.length) {
                        const propertiesHeaderContainer = $(`<div class="properties-header-container"></div>`).prependTo(listContainer);
                        headerTitles.forEach((header, i) => {
                            const style = header.style || '';
                            const classList = `editableList-header ${header.classList || ''}`
                            propertiesHeaderContainer.append(`<div class="${classList}" style="${style}">${header.title}</div>`);
                        });
                    }
                }

                function prepareEditableList(section, listHeaders) {
                    node._editableListData[section] = [];

                    const input = __$(`#${section}-section .srd-editableList-add-kv-wrp input[type="text"]`);
                    const select = __$(`#${section}-section .srd-editableList-add-kv-wrp select`);
                    const keyField = __$(`#${section}-section .srd-editableList-add-kv-wrp [editable-list-field="key"]`);
                    const listContainer = __$(`#${section}-list`).parent();
                    function updateEditableListData(prop, val, currentRowIdArr) {
                        const i = node._editableListData[section].findIndex(element => currentRowIdArr === element['rowId']);
                        node._editableListData[section][i][prop] = val;
                        return i;
                    }

                    function onItemRemoved(data) {
                        node._editableListData[section] = node._editableListData[section].filter(vObj => vObj['rowId'] !== data.rowData.rowId);
                        validate(editableList, section);
                        if (node._editableListData[section].length === 0) {
                            listContainer.hide();
                        }
                    }
                    createEditableListHeaders(listHeaders, listContainer);
                    const editableList = __$(`#${section}-list`).data({ valid: true, isUnique: true, isValid: true });
                    editableList.editableList({
                        addItem: function (container, i, data) {
                            const rowData = data.rowData || {};
                            let dataObj = {};
                            function updations(prop, elemData, inputVal) {
                                let index = updateEditableListData(prop, inputVal, container.data().data.rowData.rowId);
                                node._editableListData[section][index].valid = elemData ? elemData.valid : node._editableListData[section][index].valid;
                                container.data('data', { rowData: node._editableListData[section][index] });
                                validate(editableList, section);
                            }
                            select.each(function () {
                                const selectElm = $(this);
                                const rowItem = $(`<select class="property-value"></select>`).appendTo(container).selectField({
                                    optionsData: options.cookies,
                                    value: rowData[selectElm.attr('editable-list-field')] || selectElm.selectField('selected'),
                                    change: function (val) {
                                        updations(selectElm.attr('editable-list-field'), null, val);
                                    }
                                });
                                dataObj[selectElm.attr('editable-list-field')] = rowItem.selectField('selected');
                            });

                            input.each(function () {
                                const inputElm = $(this);
                                const rowItem = $(`<input type="text" class="property-value" inputField/>`).appendTo(container).inputField({
                                    validatorRegexp: SD.validators.patterns.noblank,
                                    wrapperAttr: { style: 'width: 40%' },
                                    value: rowData[inputElm.attr('editable-list-field')] || inputElm.val(),
                                    updations: function (elemData, inputVal) {
                                        let valid = true;
                                        container.find('[inputField]').each(function () {
                                            valid = valid && $(this).inputField('valid');
                                        });
                                        updations(inputElm.attr('editable-list-field'), { valid }, inputVal);
                                    }
                                });
                                dataObj[inputElm.attr('editable-list-field')] = rowItem.val();
                            })
                            dataObj = {
                                ...dataObj,
                                rowId: rowData.rowId || SD.nodes.id(),
                                valid: true
                            };
                            node._editableListData[section].push(dataObj);
                            listContainer.show();
                            container.attr('id', dataObj.rowId).data('data', { rowData: dataObj });
                            input.inputField('reset');
                        },
                        removable: true,
                        scrollOnAdd: true,
                        showAddBtnLabel: false,
                        removeItem: function (data) {
                            onItemRemoved(data, section, listContainer, true);
                        },
                        validator: function () {
                            if (![...input].every((elm) => $(elm).inputField('valid'))) {
                                SD.dialogService.openSnackBar('Invalid value');
                                return false;
                            }
                            if (node._editableListData[section].find(vObj => vObj['key'] === keyField.val())) {
                                SD.dialogService.openSnackBar('Duplicate value.');
                                return false;
                            }
                            return true;
                        }
                    });
                    __$(`#${section}-section .add-prop-btn-wrp`)
                        .appendTo(`#${section}-section .srd-editableList-add-kv-wrp`).css({ margin: 'auto' });
                    listContainer.hide();
                }

                function populateExistingVariables(sectionName) {
                    const list = __$(`#${sectionName}-list`)
                    if (node.editableListData[sectionName] && node.editableListData[sectionName] instanceof Array) {
                        for (let row of node.editableListData[sectionName])
                            list.editableList('addItem', { rowData: row, validator: false });
                    }
                }

                const headers = {
                    headers: [
                        { title: SD._('common.label.key'), style: 'left: 9.5%; top: 0.15em;' },
                        { title: SD._('common.label.value'), style: 'left: 50%; top: 0.15em;' }
                    ]
                }

                var headersSwitchState = SD.utils.switchFields({
                    scope: '#dialog-form',
                    stateToFieldMap: stateToFieldMapObj('headers'),
                    switcher: '#headers-switch',
                    initialState: node.switchStates['headers'],
                    imageContainer: '#headers-switch',
                    afterSwitch: validateForm
                });


                /* Cookies */

                const cookiesTemplate = `
                    <div id="%section%-section" class="cookie-section props-section accordion">
                        <div class="pallete-category-title cursor-pointer">
                            <div pallete-category-title-text>Cookie</div>
                            <img src="assets/pallete_icons/arrow_down.svg">
                            <button class="remove-cookie-button" id="%section%-remove" title="Remove this cookie"></button>
                        </div>
                        <div id="%section%-accordion-content">
                            <input type="text" id="cookies-name" placeholder="[n-sd]common.label.name" required>
                            <label class="editor-form-row-label">Value</label>
                            <input type="text" id="cookies-value">
                            <label class="editor-form-row-label">Cookies option</label>
                            <div class="srd-editableList-add-kv-wrp">
                                <select class="property-value" editable-list-field="key">
                                <input type="text" class="property-value" editable-list-field="value">
                            </div>
                            <div class="properties-container" validatesform="true">
                                <ol id="%section%-list"></ol>
                            </div>
                            <span class="list-keys-invalid">Editable List Invalid</span>
                        </div>
                    </div>
                    `
                function attachWidgetsForCookieFields(sectionId, cookieObject = { name: '', value: {} }) {
                    const { name, value } = cookieObject;
                    const section = __$(sectionId);
                    const cookieName = section.find('#cookies-name').inputField({
                        value: name,
                        wrapperClass: 'editor-form-row',
                        validator: function (val) {
                            return {
                                valid: SD.validators.patterns.noblank.test(val) &&
                                    !Object.keys(node._cookiesList).some(key => key !== sectionId && node._cookiesList[key].name === val),
                                errorMessage: ''
                            }
                        },
                        validateOnCreate: true,
                        noformvalidation: false,
                        updations: function (data, val) {
                            node._cookiesList[sectionId]['name'] = val;
                            node._cookiesList[sectionId]['valid'] = data.valid && cookieValue.typedInput('valid');
                        },
                        change: function (data, val) {
                            const catTitle = val.length > 45 ? val.slice(0, 45) + '...' : val;
                            section.find('[pallete-category-title-text]').text('cookie-' + catTitle);
                        }
                    });
                    const cookieValue = section.find('#cookies-value').css({ width: '100%' }).typedInput({
                        types: bhtypes.concat(strtype, literalType),
                        noformvalidation: false,
                        default: value.type,
                        onvalchanged: function (type, value, valid) {
                            if (node._cookiesList[sectionId]) {
                                node._cookiesList[sectionId]['value'] = { type: type, value: value };
                                node._cookiesList[sectionId]['valid'] = valid && cookieName.inputField('valid');
                            }
                        }
                    }).typedInput('value', value.value);
                    section.find('[editable-list-field]').each(function () {
                        if (this.nodeName === 'SELECT') {
                            $(this).selectField({
                                optionsData: options.cookies
                            });
                        } else {
                            $(this).inputField({
                                placeholder: SD._("common.label.value"),
                                validatorRegexp: SD.validators.patterns.noblank
                            });
                        }
                    })
                }

                node._cookiesList = {};

                function getCookieId(sectionId) {
                    return sectionId ? sectionId.slice(1, sectionId.length + 1).replace('-section', '')
                        : 'cookie-' + SD.nodes.id()
                }

                function attchRemoveCookieListener(removeCookieBtn, sectionId) {
                    removeCookieBtn.click(function () {
                        __$(sectionId).accordion('destroy');
                        __$(sectionId).remove();
                        delete node._cookiesList[sectionId];
                        delete node._editableListData[getCookieId(sectionId)];
                        validateForm();
                    })
                }

                function addCookie(id, cookieObject) {
                    const cookieId = getCookieId(id);
                    const sectionId = '#' + cookieId + '-section';
                    const cookieSectionString = cookiesTemplate.replace(/%section%/g, cookieId);
                    const cookieSection = $(cookieSectionString).accordion({
                        animate: 100,
                        heightStyle: "content",
                        collapsible: true,
                        header: '.pallete-category-title'
                    }).prependTo('#editableList-cookies');
                    attchRemoveCookieListener(cookieSection.find('#' + cookieId + '-remove'), sectionId);
                    attachWidgetsForCookieFields(sectionId, cookieObject);
                    prepareEditableList(cookieId);
                    node._cookiesList[sectionId] = cookieObject || { name: null, valid: undefined, valid: false };
                }


                __$('#cookies-add').click(function () {
                    addCookie();
                })

                var cookiesSwitchState = SD.utils.switchFields({
                    scope: '#dialog-form',
                    stateToFieldMap: stateToFieldMapObj('cookies'),
                    switcher: '#cookies-switch',
                    initialState: node.switchStates['cookies'],
                    imageContainer: '#cookies-switch',
                    afterSwitch: function (title) {
                        if (title === 'Value') {
                            __$('button#cookies-add').hide()
                        } else {
                            __$('button#cookies-add').show()
                        }
                        validateForm();
                    }
                });

                editorPrepared = true;
                validateForm();
                Object.keys(node.cookiesList).forEach((key) => {
                    addCookie(key, node.cookiesList[key])
                });

                Object.keys(node.editableListData).forEach(section => {
                    if (!node._editableListData[section]) {
                        prepareEditableList(section, headers[section]);
                    }
                    populateExistingVariables(section);
                });

            },
            oneditsave: function (SD) {
                const form = $('#dialog-form');
                const node = this;
                let __$ = form.find.bind(form);
                const sendTypes = ['obj', 'txt'];
                const responseType = __$('#node-input-responseType').selectField('selected');
                node.switchStates = {
                    headers: __$('#headers-switch').attr('title'),
                    cookies: __$('#cookies-switch').attr('title')
                }

                __$('input[ui-element-type="typedInput"]').each(function () {
                    node[$(this).attr('id').replace('node-typedInput-', '')] = {
                        type: $(this).typedInput('type'),
                        value: $(this).typedInput('type') == 'num' ? Number($(this).typedInput('value').trim()) : $(this).typedInput('value').trim(),
                        ssd_typedInputField: true
                    }
                });
                if (node.switchStates.headers === 'Value') {
                    node._editableListData['headers'] = [];
                } else {
                    node.headers = node._editableListData['headers'].reduce((obj, v) => {
                        obj[v['key']] = v['value'];
                        return obj;
                    }, {})
                }
                if (node.switchStates.cookies === 'Value') {
                    // Delete cookies options editableList data
                    Object.keys(node._editableListData).forEach(k => {
                        if (k.startsWith('cookie')) {
                            delete node._editableListData[k];
                        }
                    });
                    // delete cookies name,value data
                    delete node._cookiesList;
                } else {
                    const cookiesArray = Object.keys(node._editableListData).filter(k => k.startsWith('cookie')).map(k => {
                        const section = '#' + k + '-section';
                        const options = node._editableListData[k].reduce((obj, v) => {
                            obj[v['key']] = v['value'];
                            return obj;
                        }, {})
                        return {
                            name: node._cookiesList[section].name,
                            value: node._cookiesList[section].value,
                            options: options
                        }
                    });
                    if (cookiesArray.length) {
                        node.cookies = cookiesArray;
                    } else {
                        delete node.cookies;
                    }
                }
                node.responseMapping = {
                    status: node.httpcode,
                    [responseType]: node.responseBody,
                }

                if (sendTypes.includes(responseType)) {
                    node.responseMapping['send'] = node.responseBody
                } else {
                    delete node.responseMapping['send'];
                }
                if (responseType === 'next') {
                    __$('#node-typedInput-httpcode').typedInput('value', '');
                    __$('#node-input-responseBody').typedInput('value', '');
                }

                node.editableListData = node._editableListData ? JSON.parse(JSON.stringify(this._editableListData)) : [];
                node.cookiesList = node._cookiesList ? JSON.parse(JSON.stringify(node._cookiesList)) : {};
                delete node._editableListData;
                delete node._cookiesList;
            },
            oneditcancel: function () {
                delete this._editableListData;
                delete this._cookiesList;
            },
            docsLink: 'http-out-node'
        }
    });
</script>