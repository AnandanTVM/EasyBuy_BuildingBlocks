const BaseComponent = require('@jatahworx/bhive-toolkits').BaseComponent;

module.exports = class ChildProcess extends BaseComponent {
  constructor(constructorOptions) {
    super(constructorOptions.id, constructorOptions.name, "neutrinos_service_designer_ChildProcess", "ChildProcess", true, true);
    this.nodeOptions = constructorOptions;
    this.viewType = 'server';
  }

  generateSnippet() {
    return (this.nodeOptions.outputType === 'execSync' || this.nodeOptions.outputType === 'fork') ? this.generateExecSnippet() : this.generateSpawnSnippet();
  }

  generateExecSnippet() {
    if (this.nodeOptions.outputType === 'execSync') {
      return `const result = execSync(${this.nodeOptions.command}, ${this.optionsObj});
        ${this.nodeOptions.resultMapping} = result.toString();`;
    } else {
      return `${this.nodeOptions.resultMapping} = fork(${this.nodeOptions.command}, ${this.spawnArgs}, ${this.optionsObj});`;
    }
  }

  generateSpawnSnippet() {
    const spawnEvents = [{
      output: '.stdout',
      event: 'data',
      resultMapVar: 'stdout'
    }, {
      output: '.stderr',
      event: 'data',
      resultMapVar: 'stderr'

    }, {
      output: '',
      event: 'close',
      resultMapVar: 'close'

    }];
    let callString = `${this.nodeOptions.processInstance}.on('error', (error) => {
       this.errorHandler(bh, error, '${this.id}');
    });`;

    for (let i = 0; i < this.connectedNodesMatrix.length; i++) {
      let spawnEventHandlers = '';
      for (let j = 0; j < this.connectedNodesMatrix[i].length; j++) {
        spawnEventHandlers += `this.${this.connectedNodesMatrix[i][j].functionName}(bh);`;
      }
      let resultMapping = this.nodeOptions[spawnEvents[i]['resultMapVar']];
      callString +=
        `${this.nodeOptions.processInstance}${spawnEvents[i]['output']}.on('${spawnEvents[i]['event']}', (data) => {
          ${resultMapping} =  data ? data.toString() : data;
          ${spawnEventHandlers}
        });`;
    }
    return ({
      nodeSnippet: `${this.nodeOptions.processInstance} = spawn(${this.nodeOptions.command}, ${this.spawnArgs}, ${this.optionsObj});
        ${callString}`,
      appendNextNodePlaceholder: false
    });

  }

  generateImports(rootPaths) {
    return [
      {
        library: 'child_process',
        modules: ['spawn', 'execSync', 'fork']
      }
    ];
  }

  get optionsObj() {
    return this.nodeOptions.commandOptions ? this.nodeOptions.commandOptions : JSON.stringify({});
  }

  get spawnArgs() {
    return this.nodeOptions.spawnArgs ? this.nodeOptions.spawnArgs : JSON.stringify([]);
  }

}