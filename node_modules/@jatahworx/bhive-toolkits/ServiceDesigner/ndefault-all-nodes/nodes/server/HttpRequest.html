<script type="text/x-red" data-template-name="HttpRequest">
<!-- Method -->
    <div class="http-container editor-form-row-error-msg">
        <label for="node-input-method-select"> <span data-i18n="http-request-server.label.method"></span></label>
        <div class="http-element-container">
            <select id="node-input-method-select" class="select-method">
            </select>
            <div class="form-row field-wrapper-typedInput display-none" id="node-input-method-map-container">
                <input type="text" id="node-input-method-map" class="node-input-property typed-input-width"
                    style="width: 100% !important" />
                <input type="hidden" id="node-input-outputs" />
            </div>
            <button class="map-button-wrp">
                <image id="node-input-method-button" class="map-button" title="Map"
                    src="assets/serviceDesigner/refresh.svg"></image>
            </button>
        </div>
        <div class="error-msg-container"><span id="invalid-method-mapping-error" class="invalid-select display-none">Invalid
                Mapping</span></div>
    </div>
    
    <!-- Url -->
    <div class="http-container editor-form-row-error-msg">
        <label for="node-input-url" class="editor-form-row-label"> <span
                data-i18n="http-request-server.label.url"></span></label>
        <div class="http-element-container">
            <input type="text" id="node-input-url">
            <div class="form-row field-wrapper-typedInput display-none" id="node-input-url-map-container">
                <input type="text" id="node-input-url-map" class="node-input-property typed-input-width"
                    style="width: 100% !important" />
                <input type="hidden" id="node-input-outputs" />
            </div>
            <button class="map-button-wrp">
                <image id="node-input-url-button" class="map-button" title="Map" src="assets/serviceDesigner/refresh.svg">
                </image>
            </button>
        </div>
        <div class="error-msg-container">
            <span id="invalid-url-mapping-error" class="invalid-select display-none">Invalid Mapping</span>
        </div>
    </div>
    
    <!-- ReturnType -->
    <div class="http-container editor-form-row-error-msg">
        <label for="node-input-returntype-select"> <span data-i18n="http-request-server.label.returntype"></span></label>
        <div class="http-element-container">
            <select id="node-input-returntype-select" class="select-method">
            </select>
            <div class="form-row field-wrapper-typedInput display-none" id="node-input-returntype-map-container">
                <input type="text" id="node-input-returntype-map" class="node-input-property typed-input-width"
                    style="width: 100% !important" />
                <input type="hidden" id="node-input-outputs" />
            </div>
            <button class="map-button-wrp">
                <image id="node-input-returntype-button" class="map-button" title="Map"
                    src="assets/serviceDesigner/refresh.svg">
                </image>
            </button>
        </div>
        <div class="error-msg-container"><span id="invalid-returntype-mapping-error"
                class="invalid-select display-none">Invalid Mapping</span></div>
    </div>
    
    <!-- Body -->
    <div class="http-container editor-form-row">
        <label for="node-input-body" class="editor-form-row-label"><span
                data-i18n="http-request-server.label.body"></span></label>
        <div class="form-row  field-wrapper-typedInput" id="node-input-body">
            <input type="text" id="node-input-body-map" class="node-input-property typed-input-width"
                style="width: 100% !important" />
            <input type="hidden" id="node-input-outputs" />
        </div>
    </div>
    
    <!-- Result Mapping -->
    <div class="http-container editor-form-row-error-msg">
        <label for="node-input-result-mapping" class="editor-form-row-label"><span
                data-i18n="common.label.result-mapping"></span></label>
        <div class="form-row  field-wrapper-typedInput http-element-container" id="node-input-result-mapping">
            <input type="text" id="node-input-result-mapping-map" class="node-input-property typed-input-width"
                style="width: 100% !important" />
            <input type="hidden" id="node-input-outputs" />
        </div>
        <div class="error-msg-container"><span id="invalid-resultmapping-mapping-error"
                class="invalid-select display-none">Invalid Mapping</span></div>
    </div>
    
    <!-- Headers -->
    <div id="props-section-container" class="http-container editor-form-row margin-bottom-0">
        <div style="display: flex">
            <label for="headers-props-section">
                <span data-i18n="common.label.headers-title"></span>
            </label>
            <image style="display:none !important;" id="node-input-headers-button" title="Map" />
            </image>
        </div>
        <div class="form-row field-wrapper-typedInput display-none editor-form-row align-items-center"
            id="node-input-headers-map-container">
            <input type="text" id="node-input-headers-map" class="node-input-property typed-input-width"
                style="width: 100% !important;" />
            <input type="hidden" id="node-input-outputs" />
            <button class="map-button-wrp" style="height: 100%; margin-top: 0.75em">
                <image class="map-button proxy-map-value-toggle-headers" title="Value" src="assets/serviceDesigner/edit.svg"
                    style="margin-bottom: 0.75em;"></image>
            </button>
        </div>
        <div id="headers-props-section" class="props-section editor-form-row-error-msg">
            <div class="add-section headers-section">
                <div class="srd-editableList-add-kv-wrp">
                    <input type="text" class="property-key" name="headers-key">
                    <input type="text" class="property-value" name="headers-value">
                </div>
                <button class="map-button-wrp" style="margin-left: 0em;">
                    <image class="map-button proxy-map-value-toggle-headers" title="Map"
                        src="assets/serviceDesigner/refresh.svg">
                    </image>
                </button>
            </div>
            <div class="properties-container" validatesform="true">
                <ol id="headers-properties-content"></ol>
            </div>
            <div class="error-msg-container">
                <span class="list-keys-invalid">{{Editable List Invalid Message}}</span>
            </div>
        </div>
    </div>
    
    <!-- Params  -->
    <div id="props-section-container" class="http-container editor-form-row" style="margin-bottom: 0rem;">
        <div style="display: flex">
            <label for="params-props-section">
                <span data-i18n="common.label.params-title"></span>
            </label>
            <image style="display:none !important;" id="node-input-params-button" title="Map" />
            </image>
        </div>
        <div class="editor-form-row http-element-container field-wrapper-typedInput display-none"
            id="node-input-params-map-container">
            <input type="text" id="node-input-params-map" class="node-input-property typed-input-width"
                style="width: 100% !important" />
            <input type="hidden" id="node-input-outputs" />
            <button class="map-button-wrp" style="height: 100%; margin-top: 0.75em;">
                <image class="map-button proxy-map-value-toggle-params" title="Value" src="assets/serviceDesigner/edit.svg"
                    style="margin-bottom: 0.75em;"></image>
            </button>
        </div>
        <div id="params-props-section" class="props-section editor-form-row-error-msg">
            <div class="add-section params-section">
                <div class="srd-editableList-add-kv-wrp">
                    <input type="text" class="property-key" name="params-key">
                    <input type="text" class="property-value" name="params-value">
                </div>
                <button class="map-button-wrp" style="margin-left: 0em;">
                    <image class="map-button proxy-map-value-toggle-params" title="Map"
                        src="assets/serviceDesigner/refresh.svg">
                    </image>
                </button>
            </div>
            <div class="properties-container" validatesform="true">
                <ol id="params-properties-content"></ol>
            </div>
            <div class="error-msg-container">
                <span class="list-keys-invalid">{{Editable List Invalid Message}}</span>
                <div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Timeout -->
    <div class="http-container">
        <label for="node-input-timeout" class="editor-form-row-label"><span data-i18n="common.label.timeout"></span></label>
        <div class="form-row  field-wrapper-typedInput" id="node-input-timeout">
            <input type="text" id="node-input-timeout-map" class="node-input-property typed-input-width"
                style="width: 100% !important" />
            <input type="hidden" id="node-input-outputs" />
        </div>
        <div class="error-msg-container"><span id="invalid-resultmapping-mapping-error"
                class="invalid-select display-none">Invalid Mapping</span></div>
    </div>
    
    <!-- paytoqs -->
    <input type="checkbox" id="node-input-paytoqs">
    
    <!-- use-authentication -->
    <div class="editor-form-row">
        <!-- <div class="editor-form-row-with-sub-ele"> -->
        <input type="checkbox" id="node-input-useAuthentication">
        <!-- </div> -->
    
        <div id="use-auth-details" style="display:none !important; padding-left: 1em; margin-top: 0.6rem">
            <!-- auth type -->
            <div class="http-container editor-form-row-sub-ele">
                <label for="node-input-use-auth-type-select"> <span
                        data-i18n="http-request-server.label.auth-type"></span></label>
                <div class="http-element-container">
                    <select id="node-input-use-auth-type-select" class="select-method">
                    </select>
                    <div class="form-row field-wrapper-typedInput display-none" id="node-input-use-auth-type-map-container"
                        style="height: 2.2em">
                        <input type="text" id="node-input-use-auth-type-map" class="node-input-property typed-input-width"
                            style="width: 100% !important" />
                        <input type="hidden" id="node-input-outputs" />
                    </div>
                    <button class="map-button-wrp">
                        <image id="node-input-use-auth-type-button" class="map-button" title="Map"
                            src="assets/serviceDesigner/refresh.svg"></image>
                    </button>
                </div>
            </div>
            <!-- Username -->
            <div id="user-pass-container">
                <div class="http-container editor-form-row-sub-ele">
                    <label for="node-input-use-auth-username" class="label-input"><span
                            data-i18n="http-request-server.label.username"></span></label>
                    <div class="form-row  field-wrapper-typedInput" id="node-input-username">
                        <input type="text" id="node-input-use-auth-username-map"
                            class="node-input-property typed-input-width" style="width: 100% !important" />
                        <input type="hidden" id="node-input-outputs" />
                    </div>
                </div>
                <!-- password -->
                <div class="http-container editor-form-row-sub-ele" style="margin-bottom:0rem">
                    <label for="node-input-use-auth-password-map" class="label-input"><span
                            data-i18n="http-request-server.label.password"></span></label>
                    <div class="form-row  field-wrapper-typedInput" id="node-input-password">
                        <input type="text" id="node-input-use-auth-password-map"
                            class="node-input-property typed-input-width" style="width: 100% !important" />
                        <input type="hidden" id="node-input-outputs" />
                    </div>
                </div>
            </div>
    
            <!-- Token -->
            <div class="http-container" id="node-input-use-auth-token-map-container" style="margin-top: 1rem;">
                <label for="node-input-use-auth-token-map" class="label-input"><span
                        data-i18n="http-request-server.label.token"></span></label>
                <div class="form-row  field-wrapper-typedInput" id="node-input-token">
                    <input type="text" id="node-input-use-auth-token-map" class="node-input-property typed-input-width"
                        style="width: 100% !important" />
                    <input type="hidden" id="node-input-outputs" />
                </div>
            </div>
        </div>
    </div>
    
    <!-- SSL/TLS config node -->
    <div class="editor-form-row">
        <div class="">
            <input type="checkbox" id="node-input-usetls">
        </div>
        <div style="padding-left: 1em;" id="node-row-tls-container">
            <label class="n-sd-select-label" style="width: auto" for="node-input-tls">
                <span data-i18n="httpin.tls-config"></span>
            </label>
            <div id="node-row-tls">
                <input type="text" id="node-input-tls">
            </div>
        </div>
    </div>
    
    <!-- Use proxy config node -->
    <div class="editor-form-row">
        <input type="checkbox" id="node-input-useProxy">
        <div id="node-row-proxy-container" style="padding-left: 1em;">
            <label class="n-sd-select-label" style="width: auto;" for="node-input-proxy">
                <span data-i18n="http-request-server.label.proxy-config"></span>
            </label>
            <div id="node-row-proxy">
                <input type="text" style="width: auto" id="node-input-proxy">
            </div>
        </div>
    </div>
    
    <!-- Follow Redirects-->
    <input type="checkbox" id="node-input-followRedirect">
    
    <!-- Reject unauthorised -->
    <input type="checkbox" id="node-input-rejectUnauthorized">

    <!-- Use Query String -->
    <input type="checkbox" id="node-input-useQueryString">
    
    <!-- Cookies(List(editableList) <=> typedInput) -->
    <div id="cookies-container" class="http-container">
        <div style="display:flex"><span style="display:flex; flex: 1" data-i18n="common.label.cookies-title"></span>
            <button class="map-button-wrp" id="cookies-add" title="Add Cookie">
                <image class="map-button" src="assets/serviceDesigner/add-node-kv.svg"></image>
            </button>
            <button id="cookies-switch"></button>
        </div>
        <div id="editableList-cookies" class="props-section" style="margin-top: 1em;"></div>
        <div class="form-row  editor-form-row" id="typedInput-cookies">
            <input type="text" id="node-typedInput-cookies" class="node-input-property typed-input-width"
                style="width: 100% !important" />
            <input type="hidden" id="node-input-outputs" />
        </div>
    </div>
    
    </script>

<script type="text/javascript">
    registerNode({
        nodeType: 'HttpRequest',
        serviceType: 'server',
        nodeDef: {
            category: 'HTTP',
            color: "#009975",
            defaults: {
                name: { value: "" },
                method: {
                    value: '', validate: function (v) {
                        return this.methodMapping || v;
                    }
                },
                methodMapping: {
                    value: '', validate: function (v) {
                        return this.method || v;
                    }
                },
                methodMappingObj: { value: {} },
                urlValue: {
                    value: '', validate: function (v) {
                        return this.urlMapping || v;
                    }
                },
                urlMapping: {
                    value: '', validate: function (v) {
                        return this.urlValue || v;
                    }
                },
                urlMappingObj: { value: {} },
                ret: {
                    value: '', validate: function (v) {
                        return this.retMapping || v
                    }
                },
                retMapping: {
                    value: '', validate: function (v) {
                        return this.ret || v
                    }
                },
                retMappingObj: { value: {} },
                reqBody: { value: '' },
                reqBodyObj: { value: {} },
                resultMapping: { value: '', required: true },
                resultMappingObj: { value: {} },
                headers: { value: [] },
                headersObj: { value: {} },
                headerMapping: { value: '' },
                headerMappingObj: { value: {} },
                params: { value: [] },
                paramsObj: { value: {} },
                paramMapping: { value: '' },
                paramMappingObj: { value: {} },
                authType: { value: '' },
                useAuthTypeMappingObj: { value: {} },
                useAuthTypeMap: { value: {} },
                useAuthType: { value: '' },
                useAuthUsername: { value: '' },
                useAuthUsernameMappingObj: { value: '' },
                useAuthPassword: { value: '' },
                useAuthPasswordMappingObj: { value: '' },
                useAuthToken: { value: '' },
                useAuthTokenMappingObj: { value: '' },
                useQueryString:{value: false},
                tls: { type: "tls-config", required: false },
                followRedirect: { value: true },
                paytoqs: { value: false },
                useAuthentication: { value: false },
                rejectUnauthorized: { value: false },
                proxy: { type: "httpProxy-config", required: false },
                useProxy: { value: false },
                usetls: { value: false },
                cookies: { value: [] },
                cookiesMapObj: { value: {} },
                cookiesList: {
                    value: {}
                },
                switchStates: {
                    value: {
                        cookies: 'Map'
                    }
                },
                editableListData: { value: {} },
                timeout: { value: {} }
            },
            inputs: 1,
            outputs: 1,
            icon: "ndefault-all-nodes/http-node.svg",
            paletteLabel: function (def) { return 'HTTP Request'; },
            label: function () {
                return this.name || "HTTP Request";
            },
            labelStyle: function () {
                return this.name ? "node_label_italic" : "";
            },
            oneditprepare: function (SRD) {
                const node = this; // this refers to the node on which we are changing the properties
                const form = $('#dialog-form');
                let __$ = form.find.bind(form);
                node._editableListData = {};
                const httpMethods = [
                    { value: 'get', displayValue: 'GET' },
                    { value: 'post', displayValue: 'POST' },
                    { value: 'put', displayValue: 'PUT' },
                    { value: 'delete', displayValue: 'DELETE' },
                    { value: 'patch', displayValue: 'PATCH' },
                ];
                const responseTypes = [
                    { value: 'json', displayValue: 'JSON' },
                    { value: 'text', displayValue: 'STRING' },
                    { value: 'arraybuffer', displayValue: 'ARRAY BUFFER' },
                ]
                const authentication = [
                    { value: 'basic', displayValue: 'basic authentication' },
                    { value: 'digest', displayValue: 'digest authentication' },
                    { value: 'bearer', displayValue: 'bearer authentication' }
                ]

                const options = {
                    responseType: [
                        { value: 'bin', displayValue: 'Binary buffer' },
                        { value: 'obj', displayValue: 'JSON' },
                        { value: 'txt', displayValue: 'Plain text' },
                        { value: 'next', displayValue: 'Next Middleware' },
                    ],
                    cookies: [
                        { value: 'domain', displayValue: 'Domain name' },
                        { value: 'expires', displayValue: 'Expiry date' },
                        { value: 'httpOnly', displayValue: 'Http only' },
                        { value: 'maxAge', displayValue: 'Maximum age' },
                        { value: 'path', displayValue: 'Path' },
                        { value: 'secure', displayValue: 'Secure' },
                        { value: 'signed', displayValue: 'Signed' },
                        { value: 'sameSite', displayValue: 'Same Site' }
                    ]
                }

                const types = [
                    { value: 'bh', label: 'bh.', validate: SRD.validators.patterns.noblank },
                    { value: 'bh.input', label: 'bh.input.', validate: SRD.validators.patterns.noblank },
                    { value: 'bh.local', label: 'bh.local.', validate: SRD.validators.patterns.noblank },
                    { value: 'literal', label: 'as is', validate: SRD.validators.patterns.noblank },
                    { value: 'str', label: 'string', validate: SRD.validators.patterns.noblank }
                ];

				const inputTypes = [
                    { value: "bh", label: 'bh.' },
                    { value: "bh.input", label: 'bh.input.' },
                    { value: "bh.local", label: 'bh.local.' }
                ];

                node.tempVarStore = { headersVariables: [], paramsVariables: [] };

                /* -------------------------  */

                function updateTLSOptions(checked) {
                    if (checked) {
                        $("#node-row-tls-container").show();
                    } else {
                        $("#node-row-tls-container").hide();
                    }
                }

                function updateProxyOptions(checked) {
                    if (checked) {
                        $("#node-row-proxy-container").show();
                    } else {
                        $("#node-row-proxy-container").hide();
                    }
                }

                function updateUseAuthOptions(checked) {
                    if (checked) {
                        $("#use-auth-details").show();
                    } else {
                        $("#use-auth-details").hide();
                    }
                }

                toggleButtonCallbackFun = {
                    useAuthentication: updateUseAuthOptions,
                    usetls: updateTLSOptions,
                    useProxy: updateProxyOptions

                }
                $('input[type=checkbox]').each(function () {
                    $(this).toggleButton({
                        label: SRD._(`http-request-server.label.${(this.id).replace('node-input-', '')}`),
                        wrapperClass: (this.id == 'node-input-followRedirect' || this.id == 'node-input-paytoqs' || this.id == 'node-input-rejectUnauthorized' || this.id == "node-input-useQueryString") ? "editor-form-row" : "",
                        afterToggle: toggleButtonCallbackFun[(this.id).replace('node-input-', '')],
                        labelId: `label-${this.id}`,
                        containerId: `container-${this.id}`,
                        inputId: `input-${this.id}`
                    });
                });

                const paytoqsWidth = $('#label-node-input-paytoqs').width();
                $('input[type=checkbox]').each(function () {
                    let eleWidth = $(`#label-${this.id}`).width();
                    let leftVal = ((paytoqsWidth - eleWidth) + 50);
                    $(`#container-${this.id}`).css({ position: 'relative', left: leftVal })
                })

                /* -------------------------  */


                /* get called when there are any headers or params are present*/
                function populateExistingVariables(sectionName, variablesObjectArr) {
                    if (variablesObjectArr && variablesObjectArr instanceof Array) {
                        for (let row of variablesObjectArr)
                            $(`#${sectionName}-properties-content`).editableList('addItem', { rowData: row, validator: false });
                    }
                }
                /* Called to validate the table*/
                function validateForm() {
                    SRD.defaults.validateForm(true);
                }

                /* Creates the headers and params editable list section*/
                function decorateAndPopulatePropsSection(sectionName, dialogForm) {
                    /* Properties add section key-value fields */
                    let startKvWrp = $(`#${sectionName}-props-section .srd-editableList-add-kv-wrp`);
                    let keyField = $(`#${sectionName}-props-section .property-key`).inputField({
                        placeholder: SRD._('common.label.key'),
                        validatorRegexp: /[^\s]+/
                    });
                    let valueField = $(`#${sectionName}-props-section .property-value`).inputField({
                        placeholder: SRD._('common.label.value')
                    });

                    /* Properties List */
                    let propertiesContainer = $(`#${sectionName}-props-section .properties-container`);
                    let invalidListMsg = $(`#${sectionName}-props-section .list-keys-invalid`).css({ 'visibility': 'hidden' });

                    let propertiesHeaderContainer = $(`<div class="properties-header-container"></div>`).prependTo(propertiesContainer);

                    let headers = $(`
                <div class="header">No.</div>
                <div class="wide-header ">Key</div>
                <div class="wide-header wide-header-output">Value</div>
                `).appendTo(propertiesHeaderContainer);

                    let varArrType = sectionName === 'headers' ? 'headersVariables' : 'paramsVariables';

                    function updateTempVarStore(prop, val, currentRowIdArr, setRest) {
                        for (let i in node.tempVarStore[varArrType]) {
                            if (currentRowIdArr.includes(node.tempVarStore[varArrType][i]['rowId'])) {
                                node.tempVarStore[varArrType][i][prop] = val;
                                if (setRest === undefined) {
                                    return i;
                                }
                            } else if (setRest !== undefined) {
                                node.tempVarStore[varArrType][i][prop] = setRest;
                            }
                        }
                    }

                    function validateEditableList() {
                        SRD.defaults.validateForm(SRD.validators.editableList(propertiesContainer, propsContent, {
                            checkUniquenessOn: node.tempVarStore[varArrType].map(x => x.key),
                            checkValidityOn: node.tempVarStore[varArrType],
                            errorMsgContainer: invalidListMsg
                        }));
                    }

                    let propsContent = $(`#${sectionName}-properties-content`).data({ valid: true, isUnique: true, isValid: true });
                    propsContent.editableList({
                        addItem: function (container, i, data) {
                            let rowData = data.rowData || {};

                            /* property list's "key" field */
                            let listKey = $(`<input type="text"/>`).appendTo(container).inputField({
                                wrapperAttr: { style: 'width: 40%;' },
                                validatorRegexp: /[^\s]+/,
								inputClassList: "property-key",
								noformvalidation: false,
                                value: rowData.key || keyField.val(),
                                updations: function (elemData, inputVal) {
                                    let index = updateTempVarStore('key', inputVal, container.data().data.rowData.rowId);
                                    node.tempVarStore[varArrType][index].valid = elemData.valid;
                                    container.data('data', { rowData: node.tempVarStore[varArrType][index] });
                                    validateEditableList();
                                }
                            });

                            /* property list's "defaultValue" field */
                            let listVal = $(`<input type="text"/>`).appendTo(container).inputField({
                                wrapperAttr: { style: 'width: 40%;' },
                                inputClassList: "property-value",
                                value: rowData.defaultValue || valueField.val(),
                                updations: function () {
                                    let index = updateTempVarStore('defaultValue', $(event.target).val(), container.data().data.rowData.rowId);
                                    container.data('data', { rowData: node.tempVarStore[varArrType][index] });

                                }
                            });

                            let dataObj = {
                                key: listKey.val(),
                                defaultValue: listVal.val(),
                                rowId: rowData.rowId || SRD.nodes.id(),
                                valid: true
                            };

                            node.tempVarStore[varArrType].push(dataObj);
                            propertiesContainer.show();
                            container.attr('id', dataObj.rowId).data('data', { rowData: dataObj });
                            $('.property-row .field-floating-placeholder').remove();
                            /* Clear the "Add" Section input fields */
                            keyField.inputField('reset');
                            valueField.inputField('reset');
                            // outputToggle.find('input').prop('checked', false);
                            $('.srd-delete-icon').addClass('http-delete-icon')
                        },
                        showAddBtnLabel: false,
                        removable: true,
                        scrollOnAdd: true,
                        removeItem: function (data) {
                            node.tempVarStore[varArrType] = node.tempVarStore[varArrType].filter(vObj => vObj['rowId'] !== data.rowData.rowId);
                            validateEditableList();
                            if (node.tempVarStore[varArrType].length === 0) {
                                $(`#${sectionName}-props-section .properties-container`).hide();
                            }
                        },
                        validator: function () {
                            let keyToValidate = keyField.val();
                            if (!keyToValidate.match(keyField.inputField('option', 'validatorRegexp'))) {
                                SRD.dialogService.openSnackBar('Invalid key. It should contain atleast one character.');
                                return false;
                            }
                            if (node.tempVarStore[varArrType].find(vObj => vObj['key'] === keyToValidate)) {
                                SRD.dialogService.openSnackBar('Duplicate key. This key already exists.');
                                return false
                            }
                            return true;
                        }
                    });
                }

                function validate(editableList, section) {
					SRD.defaults.validateForm(SRD.validators.editableList(editableList.closest('.properties-container'), editableList, {
                        checkUniquenessOn: node._editableListData[section].map(x => x.key),
                        checkValidityOn: node._editableListData[section],
                        errorMsgContainer: __$(`#${section}-section span.list-keys-invalid`)
                    }));
                }
                function prepareEditableList(section, listHeaders) {
                    node._editableListData[section] = [];

                    const input = __$(`#${section}-section .srd-editableList-add-kv-wrp input[type="text"]`);
                    const select = __$(`#${section}-section .srd-editableList-add-kv-wrp select`);
                    const keyField = __$(`#${section}-section .srd-editableList-add-kv-wrp [editable-list-field="key"]`);
                    // const listContainer = __$(`#${section}-list`).parent();
                    const listOuterContainer = __$(`#${section}-properties-content`).parent();
                    function updateEditableListData(prop, val, currentRowIdArr) {
                        const i = node._editableListData[section].findIndex(element => currentRowIdArr === element['rowId']);
                        node._editableListData[section][i][prop] = val;
                        return i;
                    }

                    function onItemRemoved(data) {
                        node._editableListData[section] = node._editableListData[section].filter(vObj => vObj['rowId'] !== data.rowData.rowId);
                        validate(editableList, section);
                        if (node._editableListData[section].length === 0) {
                            // listContainer.hide();
                            listOuterContainer.hide();
                        }
                    }
                    // createEditableListHeaders(listHeaders, listContainer);
                    const editableList = __$(`#${section}-properties-content`).data({ valid: true, isUnique: true, isValid: true });
                    editableList.editableList({
                        addItem: function (container, i, data) {
                            const rowData = data.rowData || {};
                            let dataObj = {};
                            function updations(prop, elemData, inputVal) {
                                let index = updateEditableListData(prop, inputVal, container.data().data.rowData.rowId);
                                node._editableListData[section][index].valid = elemData ? elemData.valid : true;
                                container.data('data', { rowData: node._editableListData[section][index] });
                                validate(editableList, section);
                            }
                            select.each(function () {
                                const selectElm = $(this);
                                const rowItem = $(`<select class="property-value"></select>`).appendTo(container).selectField({
                                    optionsData: options.cookies,
                                    value: rowData[selectElm.attr('editable-list-field')] || selectElm.selectField('selected'),
                                    change: function (val) {
                                        updations(selectElm.attr('editable-list-field'), null, val);
                                    }
                                });
                                dataObj[selectElm.attr('editable-list-field')] = rowItem.selectField('selected');
                            });

                            input.each(function () {
                                const inputElm = $(this);
                                const rowItem = $(`<input type="text" class="property-value" inputField/>`).appendTo(container).inputField({
									validatorRegexp: SRD.validators.patterns.noblank,
									noformvalidation: false,
                                    wrapperAttr: { style: 'width: 40%' },
                                    value: rowData[inputElm.attr('editable-list-field')] || inputElm.val(),
                                    updations: function (elemData, inputVal) {
										let valid = true;
										container.find('[inputField]').each(function () {
											valid = valid && $(this).inputField('valid');
										});
                                        updations(inputElm.attr('editable-list-field'), { valid }, inputVal);
                                    }
                                });
                                dataObj[inputElm.attr('editable-list-field')] = rowItem.val();
                            })
                            dataObj = {
                                ...dataObj,
                                rowId: rowData.rowId || SRD.nodes.id(),
                                valid: true
                            };
                            node._editableListData[section].push(dataObj);
                            // listContainer.show();
                            listOuterContainer.show()
                            container.attr('id', dataObj.rowId).data('data', { rowData: dataObj });
                            input.inputField('reset');
                        },
                        removable: true,
                        scrollOnAdd: true,
                        showAddBtnLabel: false,
                        removeItem: function (data) {
                            onItemRemoved(data, section, listOuterContainer, true);
                        },
                        validator: function () {
                            if (![...input].every((elm) => $(elm).inputField('valid'))) {
                                SRD.dialogService.openSnackBar('Invalid value');
                                return false;
                            }
                            if (node._editableListData[section].find(vObj => vObj['key'] === keyField.val())) {
                                SRD.dialogService.openSnackBar('Duplicate value.');
                                return false;
                            }
                            return true;
                        }
                    });
                    __$(`#${section}-section .add-prop-btn-wrp`)
                        .appendTo(`#${section}-section .srd-editableList-add-kv-wrp`);
                    // listContainer.hide();
                    listOuterContainer.hide();
                    // red-ui-editableList-container
                }



                function assignProperIcon(buttonId) {
                    if ($(`#${buttonId}`).attr('title') === 'Map') {
                        $(`#${buttonId}`).attr('src', 'assets/serviceDesigner/refresh.svg');
                    } else {
                        $(`#${buttonId}`).attr('src', 'assets/serviceDesigner/edit.svg');
                    }
                }

                /* Function takes ids and values to compoares. If condition statisfies then it toggle the fields*/
                function toggleFields(id1, id2, actualValue, valueToCompare, buttonId, buttonValue) {
                    if (valueToCompare == actualValue) {
                        $(`#${id1}`).addClass('display-none');
                        $(`#${id2}`).removeClass('display-none');
                        $(`#${buttonId}`).attr('title', buttonValue);
                    } else {
                        $(`#${id2}`).addClass('display-none');
                        $(`#${id1}`).removeClass('display-none');
                        $(`#${buttonId}`).attr('title', actualValue)
                    }
                }

                /* Function to update the typedInput type and values*/
                function updateTypedInpuTypeAndValue(element, mappingObj, buttonId, id1, id2) {
                    element.typedInput('type', mappingObj['mapVarType']);
                    element.typedInput('value', mappingObj['mapVarValue']);
                    $(`#${buttonId}`).attr('title', 'Value')
                    assignProperIcon(buttonId);
                    $(`#${id1}`).addClass('display-none');
                    $(`#${id2}`).removeClass('display-none');
                }

                /* Validates the typed input and show/hide the error message*/
                function validateTypedInput(value, errorMsgId, buttonId) {
                    let isValueExists = false;
                    if ($(`#${buttonId}`).attr('title') == 'Value' || !buttonId) {
                        if (value) {
                            isValueExists = true;
                            $(`#${errorMsgId}`).addClass('display-none');
                        } else {
                            isValueExists = false;
                            $(`#${errorMsgId}`).removeClass('display-none');
                        }
                    } else {
                        $(`#${errorMsgId}`).addClass('display-none');
                        isValueExists = true
                    }
                    return isValueExists;
                }

                /* Called when there is change in the value of method typedInput */
                function validateMethod(value) {
                    const isMethodValid = validateTypedInput(value, 'invalid-method-mapping-error', 'node-input-method-button');
                    return isMethodValid;
                }

                /* Called when there is change in the value of url typedInput */
                function validateUrl(value) {
                    const isUrlValid = validateTypedInput(value, 'invalid-url-mapping-error', 'node-input-url-button');
                    return isUrlValid;
                }

                /* Called when there is change in the value of return type typedInput */
                function validateReturnType(value) {
                    const isReturnTypeValid = validateTypedInput(value, 'invalid-returntype-mapping-error', 'node-input-returntype-button');
                    return isReturnTypeValid;
                }

                /* Called when there is change in the value of result mapping typedInput */
                function validateResultMapping(value) {
                    const isResultMappingValid = validateTypedInput(value, 'invalid-resultmapping-mapping-error');
                    return isResultMappingValid;
                }

                /* Update typed input ele */
                function updateTypedInputValue(typedInputEle, mappingObj) {
                    if (node[mappingObj] && node[mappingObj].hasOwnProperty('mapVarType')) {
                        typedInputEle.typedInput('type', node[mappingObj].mapVarType);
                        typedInputEle.typedInput('value', node[mappingObj].mapVarValue)

                    }
                }

                /* Method */
                /* Creates the select to select the method*/
                const methodSelectEle = $('#node-input-method-select').selectField({
                    optionsData: httpMethods,
                    props: {
                        requirmethodTypedInputEleed: true
                    },
                    value: httpMethods[0].value
                })

                const methodTypedInputEle = $('#node-input-method-map').typedInput({
					noformvalidation: false,
                    types: [
                        { value: "bh", label: 'bh.', validate: validateMethod },
                        { value: "bh.input", label: 'bh.input.', validate: validateMethod },
                        { value: "bh.local", label: 'bh.local.', validate: validateMethod }
                    ]
                });
                $('#node-input-method-button').on('click', function () {
                    let text = $('#node-input-method-button').attr('title');
                    toggleFields('node-input-method-select', 'node-input-method-map-container', 'Map', text, 'node-input-method-button', 'Value');
                    assignProperIcon('node-input-method-button');
					methodTypedInputEle.typedInput('validate');
					SRD.defaults.validateForm(true);
                });

                if (this.methodMappingObj && this.methodMappingObj.hasOwnProperty('mapVarType')) {
                    updateTypedInpuTypeAndValue(methodTypedInputEle, this.methodMappingObj, 'node-input-method-button', 'node-input-method-select', 'node-input-method-map-container');
                    $('#node-input-method-map-container').find('.red-ui-typedInput-input').removeClass('input-error')
                } else {
                    methodSelectEle.val(this.method ? this.method : 'get')
                }

                /* URL */
                /* Creates the select to select the method*/
                const urlInputFieldEle = $('#node-input-url').inputField({
                    wrapperAttr: {
                        "id": "node-input-url-container"
					},
					noformvalidation: false,
                    validatorRegexp: /[^\s]+/,
                    validateOnCreate: true,
                    errorText: 'Url Required',
                    errorClassList: 'http-node invalid-url-msg',
                    value: node.urlValue || '',
                    disableDoneIfInvalid: true,
                    inputClassList: "property-url",
                })

                const urlTypedInputEle = $('#node-input-url-map').typedInput({
					noformvalidation: false,
                    types: [
                        { value: "bh", label: "bh.", validate: validateUrl },
                        { value: "bh.input", label: 'bh.input.', validate: validateUrl },
                        { value: "bh.local", label: 'bh.local.', validate: validateUrl }
                    ]
                });
                $('#node-input-url-button').on('click', function () {
                    let text = $('#node-input-url-button').attr('title');
                    toggleFields('node-input-url-container', 'node-input-url-map-container', 'Map', text, 'node-input-url-button', 'Value');
                    assignProperIcon('node-input-url-button');
                    if ($('#node-input-url-button').attr('title') == 'Map') {
                        $('#invalid-url-mapping-error').addClass('display-none');
                        urlInputFieldEle.trigger('input');
                    } else {
                        urlTypedInputEle.typedInput('validate');
					}
					SRD.defaults.validateForm(true);
                });

                if (this.urlMappingObj && this.urlMappingObj.hasOwnProperty('mapVarType')) {
                    updateTypedInpuTypeAndValue(urlTypedInputEle, this.urlMappingObj, 'node-input-url-button', 'node-input-url-container', 'node-input-url-map-container');
                    $('#node-input-url-map-container').find('.red-ui-typedInput-input').removeClass('input-error')
                } else {
                    urlInputFieldEle.trigger('input');
                    urlInputFieldEle.blur();
                }

                /* Return Type */
                const returnTypeSelectEle = $('#node-input-returntype-select').selectField({
                    optionsData: responseTypes,
                    showError: true,
                    validateOnCreate: true,
                    props: {
                        required: true
                    },
                    value: 'json',
                });

                const returnTypeTypedInputEle = $('#node-input-returntype-map').typedInput({
					noformvalidation: false,
                    types: [
                        { value: "bh", label: 'bh.', validate: validateReturnType },
                        { value: "bh.input", label: 'bh.input.', validate: validateReturnType },
                        { value: "bh.local", label: 'bh.local.', validate: validateReturnType }
                    ]
                });
                $('#node-input-returntype-button').on('click', function () {
                    let text = $('#node-input-returntype-button').attr('title');
                    toggleFields('node-input-returntype-select', 'node-input-returntype-map-container', 'Map', text, 'node-input-returntype-button', 'Value');
                    assignProperIcon('node-input-returntype-button');
					returnTypeTypedInputEle.typedInput('validate');
					SRD.defaults.validateForm(true);
                });

                if (this.retMappingObj && this.retMappingObj.hasOwnProperty('mapVarType')) {
                    updateTypedInpuTypeAndValue(returnTypeTypedInputEle, this.retMappingObj, 'node-input-returntype-button', 'node-input-returntype-select', 'node-input-returntype-map-container');
                    $('#node-input-returntype-map-container').find('.red-ui-typedInput-input').removeClass('input-error')
                } else {
                    returnTypeSelectEle.val(this.ret ? this.ret : 'json')
                }

                /* Body */
                const body = $('#node-input-body-map').typedInput({ types: inputTypes, noformvalidation: false });
                if (node.reqBodyObj && node.reqBodyObj.hasOwnProperty('mapVarType')) {
                    body.typedInput('type', node.reqBodyObj.mapVarType);
                    body.typedInput('value', node.reqBodyObj.mapVarValue);
                }

                /* timeout */
                const timeoutEle = $('#node-input-timeout-map').typedInput({ types: ['num', { value: 'process.env', label: 'env' }], noformvalidation: false });
                if (node.timeout && node.timeout.hasOwnProperty('type')) {
                    timeoutEle.typedInput('type', node.timeout.type);
                    timeoutEle.typedInput('value', node.timeout.value);
                }



                /* Result Mapping */
                const resultMapping = $('#node-input-result-mapping-map').typedInput({
					noformvalidation: false,
                    types: [
                        { value: "bh", label: 'bh.', validate: validateResultMapping },
                        { value: "bh.input", label: 'bh.input.', validate: validateResultMapping },
                        { value: "bh.local", label: 'bh.local.', validate: validateResultMapping }
                    ]
                });
                if (node.resultMappingObj && node.resultMappingObj.hasOwnProperty('mapVarType')) {
                    resultMapping.typedInput('type', node.resultMappingObj.mapVarType);
                    resultMapping.typedInput('value', node.resultMappingObj.mapVarValue);
                    $('#node-input-result-mapping').find('.red-ui-typedInput-input').removeClass('input-error')
                }


                /* Headers TypedInput*/
                const headersTypedInputEle = $('#node-input-headers-map').typedInput({ types: inputTypes, noformvalidation: false });
                $('.proxy-map-value-toggle-headers').click((eventObj) => {
                    let text = $('#node-input-headers-button').attr('title');
					toggleFields('headers-props-section', 'node-input-headers-map-container', 'Map', text, 'node-input-headers-button', 'Value');
					SRD.defaults.validateForm(true);
                });



                /* Params TypedInput*/
                const paramsTypedInputEle = $('#node-input-params-map').typedInput({ types: inputTypes, noformvalidation: false });
                $('.proxy-map-value-toggle-params').click((eventObj) => {
                    let text = $('#node-input-params-button').attr('title');
					toggleFields('params-props-section', 'node-input-params-map-container', 'Map', text, 'node-input-params-button', 'Value');
					SRD.defaults.validateForm(true);
                });


                const useAuthTypeSelectEle = $('#node-input-use-auth-type-select').selectField({
                    optionsData: authentication,
                    value: authentication[0].value
                });
                // useAuthenticationuseAuthentication

                function updateUserAuthDisplayFields(value) {
                    if (value != 'bearer') {
                        $('#node-input-use-auth-token-map-container').hide()
                        $('#user-pass-container').show();
                    } else {
                        $('#node-input-use-auth-token-map-container').show()
                        $('#user-pass-container').hide();

                    }
                }

                $('#node-input-use-auth-type-select').on('change', function () {
                    updateUserAuthDisplayFields(this.value);
                })

                function displayAllUserFields(text) {
                    if (text == 'Map') {
                        $('#node-input-use-auth-token-map-container').show()
                        $('#user-pass-container').show();
                    }
                    else {
                        let selectedOption = $('#node-input-use-auth-type-select').find("option:selected").val();
                        updateUserAuthDisplayFields(selectedOption)
                    }
                }

                const useAuthTypeTypedInputEle = $('#node-input-use-auth-type-map').typedInput({
					noformvalidation: false,
                    types: [
                        { value: "bh", label: 'bh.' },
                        { value: "bh.input", label: 'bh.input.' },
                        { value: "bh.local", label: 'bh.local.' }
                    ]
                });
                $('#node-input-use-auth-type-button').on('click', function () {
                    let text = $('#node-input-use-auth-type-button').attr('title');
                    toggleFields('node-input-use-auth-type-select', 'node-input-use-auth-type-map-container', 'Map', text, 'node-input-use-auth-type-button', 'Value');
                    assignProperIcon('node-input-use-auth-type-button');
                    displayAllUserFields(text);
                    // methodTypedInputEle.typedInput('validate');
                });

                let authValueTypes = [{ value: "str", label: 'string' }, { value: "process.env", label: 'env' }];
                /* Use auth username */
                const useAuthUsernameTypedInputEle = $('#node-input-use-auth-username-map').typedInput({ types: authValueTypes, noformvalidation: false });
                updateTypedInputValue(useAuthUsernameTypedInputEle, 'useAuthUsernameMappingObj')
                /* Use auth Password */
                const useAuthPasswordTypedInputEle = $('#node-input-use-auth-password-map').typedInput({ types: authValueTypes, noformvalidation: false });
                updateTypedInputValue(useAuthPasswordTypedInputEle, 'useAuthPasswordMappingObj')

                /* Use auth Token */
                const useAuthTokenTypedInputEle = $('#node-input-use-auth-token-map').typedInput({
					noformvalidation: false,
                    types: [
                        { value: "bh", label: 'bh.' },
                        { value: "bh.input", label: 'bh.input.' },
                        { value: "bh.local", label: 'bh.local.' }
                    ]
                });
                updateTypedInputValue(useAuthTokenTypedInputEle, 'useAuthTokenMappingObj')



                // if (this.useAuthTypeMap) {
                if (this.useAuthTypeMappingObj && this.useAuthTypeMappingObj.hasOwnProperty('mapVarType')) {
                    updateTypedInpuTypeAndValue(useAuthTypeTypedInputEle, this.useAuthTypeMappingObj, 'node-input-use-auth-type-button', 'node-input-use-auth-type-select', 'node-input-use-auth-type-map-container');
                    $('#node-input-use-auth-token-map-container').show()
                    $('#user-pass-container').show();
                } else {
                    useAuthTypeSelectEle.val(this.authType ? this.authType : 'basic');
                    // if(this.useAuthType != )
                    updateUserAuthDisplayFields(this.authType ? this.authType : 'basic');
                }

                if (this.useAuthentication) {
                    $("#node-input-useAuth-details").show();
                }

                /* Add input and local properties section */
                decorateAndPopulatePropsSection('headers');
                decorateAndPopulatePropsSection('params');
                // decorateAndPopulatePropsSection('cookies');

                $('.add-prop-icon').addClass('add-prop-http-icon');
                $('.add-prop-text').addClass('add-prop-http-text');
                $('.add-prop-btn').addClass('add-button-http');

                /* Hide the properties list by default. It will be displayed whenever 'addItem' runs */
                $('#params-props-section .properties-container').hide();
                $('#headers-props-section .properties-container').hide();
                $('#cookies-props-section .properties-container').hide();

                /* Populate editableList with the variables if already present */
                if (this.headerMappingObj && this.headerMappingObj.hasOwnProperty('mapVarType')) {
                    updateTypedInpuTypeAndValue(headersTypedInputEle, this.headerMappingObj, 'node-input-headers-button', 'headers-props-section', 'node-input-headers-map-container');
                    $('#node-input-result-mapping').find('.red-ui-typedInput-input').removeClass('input-error')

                } else {
                    populateExistingVariables('headers', this.headersObj);
                }

                if (this.paramMappingObj && this.paramMappingObj.hasOwnProperty('mapVarType')) {
                    updateTypedInpuTypeAndValue(paramsTypedInputEle, this.paramMappingObj, 'node-input-params-button', 'params-props-section', 'node-input-params-map-container');
                } else {
                    populateExistingVariables('params', this.paramsObj);
                }


                /* Reposition the "Add" button */
                $('.add-prop-btn-wrp').each(function (i, elem) {
                    $(elem).css('margin-left', '0.5em')
                        .insertBefore($('.add-section .map-button-wrp')[i]);
                });

                $('#dialog-form').attr('novalidate', 'novalidate');

                // Clicking 'Enter' on the map/value divs should mimic their respective 'click' behaviour.
                $('.map-button-wrp').on('keyup', (event) => {
                    if (event.key === 'Enter') {
                        $(event.target).find('img').click();
                    }
                });

                /* Cookies */
                const stateToFieldMapObj = function (section) {
                    return {
                        Map: {
                            selector: '#editableList-' + section,
                            src: 'assets/serviceDesigner/refresh.svg'
                        },
                        Value: {
                            selector: '#typedInput-' + section,
                            src: 'assets/serviceDesigner/edit.svg'
                        }
                    }
                };


                $('#node-typedInput-cookies').typedInput({
					types: types,
					noformvalidation: false
                })
                if (node.cookies && node.cookies.hasOwnProperty('type')) {
                    $("#node-typedInput-cookies").typedInput('type', node.cookies.type);
                    $("#node-typedInput-cookies").typedInput('value', node.cookies.value);
                }

                const cookiesTemplate = `
                <div id="%section%-section" class="cookie-section props-section accordion">
                    <div class="pallete-category-title cursor-pointer">
                        <div pallete-category-title-text>Cookie</div>
                        <img src="assets/pallete_icons/arrow_down.svg">
                        <button class="remove-cookie-button" id="%section%-remove" title="Remove this cookie"></button>
                    </div>
                    <div id="%section%-accordion-content">
                        <input type="text" id="cookies-name" required>
                        <label class="editor-form-row-label">Value</label>
                        <input type="text" id="cookies-value">
                        <label class="editor-form-row-label">Cookies option</label>
                        <div class="srd-editableList-add-kv-wrp">
                            <select class="property-value" editable-list-field="key">
                            <input type="text" class="property-value" editable-list-field="value">
                        </div>
                        <div class="properties-container" validatesform="true">
                            <ol id="%section%-properties-content"></ol>
                        </div>
                        <span class="list-keys-invalid">Editable List Invalid</span>
                    </div>
                </div>
                `
                function attachWidgetsForCookieFields(sectionId, cookieObject = { name: '', value: {} }) {
                    const { name, value } = cookieObject;
                    const section = __$(sectionId);
                    const cookieName = section.find('#cookies-name').inputField({
                        value: name,
                        placeholder: SRD._("common.label.name"),
                        wrapperClass: 'editor-form-row',
                        validator: function (val) {
                            return {
                                valid: SRD.validators.patterns.noblank.test(val) &&
                                    !Object.keys(node._cookiesList).some(key => key !== sectionId && node._cookiesList[key].name === val),
                                errorMessage: ''
                            }
                        },
						validateOnCreate: true,
						noformvalidation: false,
                        updations: function (data, val) {
                            node._cookiesList[sectionId]['name'] = val;
                            node._cookiesList[sectionId]['valid'] = data.valid && cookieValue.typedInput('valid');
                        },
                        change: function (data, val) {
                            const catTitle = val.length > 45 ? val.slice(0, 45) + '...' : val;
                            section.find('[pallete-category-title-text]').text('cookie-' + catTitle);
                        }
                    });
                    const cookieValue = section.find('#cookies-value').css({ width: '100%' }).typedInput({
                        types: types,
						default: value.type,
						noformvalidation: false,
                        onvalchanged: function (type, value, valid) {
                            if (node._cookiesList[sectionId]) {
                                node._cookiesList[sectionId]['value'] = { type: type, value: value };
                                node._cookiesList[sectionId]['valid'] = valid && cookieName.inputField('valid');
                            }
                        }
                    }).typedInput('value', value.value);
                    section.find('[editable-list-field]').each(function () {
                        if (this.nodeName === 'SELECT') {
                            $(this).selectField({
                                optionsData: options.cookies
                            });
                        } else {
                            $(this).inputField({
                                placeholder: SRD._("common.label.value"),
                                validatorRegexp: SRD.validators.patterns.noblank
                            });
                        }
                    })
                }

                node._cookiesList = {};

                function getCookieId(sectionId) {
                    return sectionId ? sectionId.slice(1, sectionId.length + 1).replace('-section', '')
                        : 'cookie-' + SRD.nodes.id()
                }

                function attchRemoveCookieListener(removeCookieBtn, sectionId) {
                    removeCookieBtn.click(function () {
                        __$(sectionId).accordion('destroy');
                        __$(sectionId).remove();
                        delete node._cookiesList[sectionId];
                        delete node._editableListData[getCookieId(sectionId)];
                    })
                }

                function addCookie(id, cookieObject) {
                    const cookieId = getCookieId(id);
                    const sectionId = '#' + cookieId + '-section';
                    const cookieSectionString = cookiesTemplate.replace(/%section%/g, cookieId);
                    const cookieSection = $(cookieSectionString).accordion({
                        animate: 100,
                        heightStyle: "content",
                        collapsible: true,
                        header: '.pallete-category-title'
                    }).prependTo('#editableList-cookies');
                    attchRemoveCookieListener(cookieSection.find('#' + cookieId + '-remove'), sectionId);
                    attachWidgetsForCookieFields(sectionId, cookieObject);
                    prepareEditableList(cookieId);
                    node._cookiesList[sectionId] = cookieObject || { name: null, valid: undefined, valid: false };
                }


                __$('#cookies-add').click(function () {
                    addCookie();
                })

                var cookiesSwitchState = SRD.utils.switchFields({
                    scope: '#dialog-form',
                    stateToFieldMap: stateToFieldMapObj('cookies'),
                    switcher: '#cookies-switch',
                    initialState: node.switchStates['cookies'],
                    imageContainer: '#cookies-switch',
                    afterSwitch: function (title) {
                        if (title === 'Value') {
                            __$('button#cookies-add').hide()
                        } else {
                            __$('button#cookies-add').show()
                        }
                        validateForm();
                    }
                });

                editorPrepared = true;
                validateForm();

                // prepareEditableList(section, headers[section]);
                Object.keys(node.cookiesList).forEach((key) => {
                    addCookie(key, node.cookiesList[key])
                });

                Object.keys(node.editableListData).forEach(section => {
                    if (!node._editableListData[section]) {
                        prepareEditableList(section);
                    }
                    populateExistingVariables(section, node.editableListData[section]);
                });
            },
            oneditsave: function () {
                let node = this;

                const form = $('#dialog-form');
                // const node = this;
                let __$ = form.find.bind(form);
                // const sendTypes = ['obj', 'txt'];
                node.switchStates = {
                    // headers: __$('#headers-switch').attr('title'),
                    cookies: __$('#cookies-switch').attr('title')
                }

                node.timeout.type = $(`#node-input-timeout-map`).typedInput('type')
                node.timeout.value = $(`#node-input-timeout-map`).typedInput('value')

                function updateMappingValue(id, mapVar, mapVarObj) {
                    const mapVarType = $(`#${id}`).typedInput('type');
                    const mapVarValue = $(`#${id}`).typedInput('value');
                    if (mapVarValue) {
                        node[mapVar] = `${mapVarType}.${mapVarValue}`;
                    } else {
                        node[mapVar] = undefined;
                    }
                    node[mapVarObj] = node[mapVarObj] ? node[mapVarObj] : {}
                    node[mapVarObj]['mapVarType'] = mapVarType;
                    node[mapVarObj]['mapVarValue'] = mapVarValue;
                }

                if (node.switchStates.cookies === 'Value') {
                    // Delete cookies options editableList data
                    Object.keys(node._editableListData).forEach(k => {
                        if (k.startsWith('cookie')) {
                            delete node._editableListData[k];
                        }
                    });
                    node.cookies = {};
                    node.cookies.type = $("#node-typedInput-cookies").typedInput('type');
                    node.cookies.value = $("#node-typedInput-cookies").typedInput('value');

                    // delete cookies name,value data
                    delete node._cookiesList;
                } else {
                    const cookiesArray = Object.keys(node._editableListData).filter(k => k.startsWith('cookie')).map(k => {
                        const section = '#' + k + '-section';
                        const options = node._editableListData[k].reduce((obj, v) => {
                            obj[v['key']] = v['value'];
                            return obj;
                        }, {})
                        return {
                            name: node._cookiesList[section].name,
                            value: node._cookiesList[section].value,
                            options: options
                        }
                    });
                    if (cookiesArray.length) {
                        node.cookies = cookiesArray;
                    } else {
                        delete node.cookies;
                    }
                }



                node.editableListData = node._editableListData ? JSON.parse(JSON.stringify(this._editableListData)) : [];
                node.cookiesList = node._cookiesList ? JSON.parse(JSON.stringify(node._cookiesList)) : {};
                delete node._editableListData;
                delete node._cookiesList;


                /* Method*/
                if ($('#node-input-method-button').attr('title') == 'Map') {
                    this.method = $('#node-input-method-select').val();
                    this.methodMapping = undefined;
                    this.methodMappingObj = {};
                } else {
                    this.method = undefined;
                    updateMappingValue('node-input-method-map', 'methodMapping', 'methodMappingObj');
                }



                /* Url*/
                if ($('#node-input-url-button').attr('title') == 'Map') {
                    this.urlValue = $('#node-input-url').val();
                    this.urlMapping = undefined;
                    this.urlMappingObj = {};
                } else {
                    this.urlValue = undefined;
                    updateMappingValue('node-input-url-map', 'urlMapping', 'urlMappingObj');
                }

                /* ReturnType */
                if ($('#node-input-returntype-button').attr('title') == 'Map') {
                    this.ret = $('#node-input-returntype-select').val();
                    this.retMapping = undefined;
                    this.retMappingObj = {};
                } else {
                    this.ret = undefined;
                    updateMappingValue('node-input-returntype-map', 'retMapping', 'retMappingObj');
                }

                /* Body */
                updateMappingValue('node-input-body-map', 'reqBody', 'reqBodyObj');

                /* Result Mapping */
                updateMappingValue('node-input-result-mapping-map', 'resultMapping', 'resultMappingObj');

                /* Headers */
                if ($('#node-input-headers-button').attr('title') == 'Map') {
                    const headersForCodeGen = {};
                    const headersArr = [];
                    const headersObjArr = [];
                    for (const header of this.tempVarStore.headersVariables) {
                        const key = header.key;
                        const value = header.defaultValue;
                        headersForCodeGen[key] = value;
                        headersObjArr.push({ key: key, defaultValue: value });
                    }
                    this.headers = headersForCodeGen;
                    this.headersObj = headersObjArr;
                    this.headerMapping = undefined;
                    this.headerMappingObj = {};


                } else {
                    updateMappingValue('node-input-headers-map', 'headerMapping', 'headerMappingObj');
                    this.headers = undefined;
                    this.headersObj = undefined;
                }

                /* Params */
                if ($('#node-input-params-button').attr('title') == 'Map') {
                    const paramsArr = [];
                    const paramsObjArr = [];
                    const paramsForCodeGen = {};
                    for (const param of this.tempVarStore.paramsVariables) {
                        const key = param.key;
                        const value = param.defaultValue;
                        paramsForCodeGen[key] = value;
                        paramsObjArr.push({ key: key, defaultValue: value });
                    }
                    this.params = paramsForCodeGen;
                    this.paramsObj = paramsObjArr;
                    this.paramMapping = undefined;
                    this.paramMappingObj = {};

                } else {
                    updateMappingValue('node-input-params-map', 'paramMapping', 'paramMappingObj');
                    this.params = undefined;
                    this.paramsObj = undefined;
                }

                // node.rejectUnauthorized = $('#reject-unauthorized').is(':checked')
                /* use tls */
                node.usetls = $('#node-input-usetls').is(':checked');
                if (!node.usetls) {
                    $('#node-input-tls').val("_ADD_");
                }
                /* use http proxy */
                node.useProxy = $('#node-input-useProxy').is(':checked');
                if (!node.useProxy) {
                    $('#node-input-proxy').val("_ADD_")
                }

                node.useAuthentication = $("#node-input-useAuthentication").is(":checked");
                if (node.useAuthentication) {
                    if ($('#node-input-use-auth-type-button').attr('title') == 'Map') {
                        let authType = $('#node-input-use-auth-type-select').find("option:selected").val();
                        node.authType = authType;
                        if (authType != 'bearer') {
                            updateMappingValue('node-input-use-auth-username-map', 'useAuthUsername', 'useAuthUsernameMappingObj');
                            updateMappingValue('node-input-use-auth-password-map', 'useAuthPassword', 'useAuthPasswordMappingObj');
                            node.useAuthTokenMappingObj = undefined;
                        } else {
                            updateMappingValue('node-input-use-auth-token-map', 'useAuthToken', 'useAuthTokenMappingObj');
                            node.useAuthPasswordMappingObj = {};
                            node.useAuthUsernameMappingObj = {}
                        }
                        // node.authType = node.useAuthType
                        node.useAuthTypeMap = undefined;
                        node.useAuthTypeMappingObj = undefined;
                    } else {
                        updateMappingValue('node-input-use-auth-type-map', 'useAuthTypeMap', 'useAuthTypeMappingObj');
                        updateMappingValue('node-input-use-auth-username-map', 'useAuthUsername', 'useAuthUsernameMappingObj');
                        updateMappingValue('node-input-use-auth-password-map', 'useAuthPassword', 'useAuthPasswordMappingObj');
                        updateMappingValue('node-input-use-auth-token-map', 'useAuthToken', 'useAuthTokenMappingObj');
                        node.authType = node.useAuthTypeMap;
                        node.useAuthType = undefined
                    }

                } else {
                    node.useAuthTypeMap = undefined;
                    node.useAuthType = undefined
                    node.authType = undefined;
                }
                node.followRedirect = $('#node-input-followRedirect').is(':checked')
                delete this.tempVarStore;
            },
            oneditcancel: function () {
                delete this.tempVarStore;
                delete this._editableListData;
                delete this._cookiesList;
            },
            oneditresize: function (size) {
                $('.properties-container .wide-header').width($('.properties-container .field-wrapper').width()).css({
                    'margin-left': '1em'
                });
            },
            docsLink: 'http-request-node'
        }
    });
</script>