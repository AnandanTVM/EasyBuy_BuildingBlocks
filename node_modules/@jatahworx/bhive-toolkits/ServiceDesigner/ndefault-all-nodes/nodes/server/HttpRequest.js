let BaseComponent = require("@jatahworx/bhive-toolkits").BaseComponent;
let util = require("@jatahworx/bhive-toolkits").SRDCodeGenUtil;

module.exports = class HttpRequest extends BaseComponent {
    constructor(constructorOptions) {
        super(constructorOptions.id, constructorOptions.name, "neutrinos_service_designer_http", "HttpRequest");

        // http method - get, post, put.. etc...
        this.method = constructorOptions.methodMapping || JSON.stringify(constructorOptions.method);
        this.url = constructorOptions.urlMapping || JSON.stringify(constructorOptions.urlValue);
        // return type
        // bin || obj || txt
        this.ret = constructorOptions.retMapping || JSON.stringify(constructorOptions.ret);
        this.enableTls = constructorOptions.enableTls;
        this.body = constructorOptions.reqBody;
        this.requestTimeout = constructorOptions.timeout;
        this.params = constructorOptions.paramMapping || JSON.stringify(constructorOptions.params);
        // array of key value pairs
        this.headers = constructorOptions.headerMapping || JSON.stringify(constructorOptions.headers);
        this.resultMapping = constructorOptions.resultMapping;
        this.followRedirects = constructorOptions.followRedirect; // true by default
        this.cookies = constructorOptions.cookies;
        this.viewType = 'server';
        this.authType = constructorOptions.authType || constructorOptions.useAuthTypeMappingObj
        this.username = constructorOptions.useAuthUsernameMappingObj
        this.password = constructorOptions.useAuthPasswordMappingObj
        this.token = constructorOptions.useAuthTokenMappingObj
        this.paytoqs = constructorOptions.paytoqs;
        this.tlsConfigId = constructorOptions.tls;
        this.proxyConfigId = constructorOptions.proxy;
        this.rejectUnauthorized = constructorOptions.rejectUnauthorized;
        this.useAuth = constructorOptions.useAuthentication;
        this.useQueryString = constructorOptions.useQueryString;

    }

    generateSnippet() {
        if (!this.ret) {
            throw new Error('Invalid return type');
        }
        if (!isNaN(this.requestTimeout) && this.requestTimeout < 1) {
            throw new Error(`timeout cannot be a ${this.requestTimeout}`);
        }

        return `let requestOptions = {
				url: ${this.url},
				timeout: ${this.requestTimeout},
				method: ${this.method},
				headers: ${this.headers},
				followRedirects: ${this.followRedirects},
				cookies: ${this.cookies},
				authType: ${this.authType},
				body: ${this.body},
				paytoqs: ${this.paytoqs},
				proxyConfig: ${undefined},
				tlsConfig: ${undefined},
				ret: ${this.ret},
				params: ${this.params},
				username: ${this.username},
				password: ${this.password},
				token: ${this.token},
				rejectUnauthorized: undefined,
                useQuerystring: ${this.useQueryString},
				};
                if (!${this.rejectUnauthorized}) {
                    requestOptions.rejectUnauthorized = ${this.rejectUnauthorized}
                }
				${this.tlsConfig};
				${this.proxyConfig};
				let responseMsg: any = await this.sdService.httpRequest(requestOptions.url,
				requestOptions.timeout,
				requestOptions.method,
				requestOptions.headers,
				requestOptions.followRedirects,
				requestOptions.cookies,
				requestOptions.authType,
				requestOptions.body,
				requestOptions.paytoqs,
				requestOptions.proxyConfig,
				requestOptions.tlsConfig,
				requestOptions.ret,
				requestOptions.params,
				requestOptions.rejectUnauthorized,
				requestOptions.username,
				requestOptions.password,
				requestOptions.token, 
				);

				${this.__addResponses()};`
    }

    __addResponses() {
        let responseString = `${this.resultMapping} = responseMsg`;
        return responseString;
    }


    /********* getters and setters******** */

    set ret(ret) {
        this._ret = ret;
    }

    get ret() {
        return this._ret;
    }

    set tlsConfigId(configId) {
        if (configId) {
            this._tlsConfigId = configId
        }
        else {
            this._tlsConfigId = null;
        }
    }

    get tlsConfigId() {
        return this._tlsConfigId;
    }

    get tlsConfig() {
        if (this.tlsConfigId) {
            return `requestOptions.tlsConfig = this.sdService.getConfigObj('tls-config','${this.tlsConfigId}')`;
        }
        else {
            return `requestOptions.tlsConfig = undefined`
        }
    }

    set proxyConfigId(configId) {
        if (configId) {
            this._proxyConfigId = configId;
        }
        else {
            this._proxyConfigId = null;
        }
    }

    get proxyConfigId() {
        return this._proxyConfigId;
    }

    get proxyConfig() {
        if (this.proxyConfigId) {
            return `requestOptions.proxyConfig = this.sdService.getConfigObj('httpProxy-config','${this.proxyConfigId}')`;
        } else {
            return `requestOptions.proxyConfig = undefined`
        }

    }

    set paytoqs(paytoqs) {
        if (typeof paytoqs === 'boolean') {
            this._paytoqs = paytoqs;
        }
        else if (typeof paytoqs === 'undefined') {
            this._paytoqs = false;
        }

    }

    get paytoqs() {
        return this._paytoqs;
    }

    set credentials(credentials) {
        if (credentials) {
            this._credentials = credentials;
        }
        else {
            credentials = null;
        }
    }

    get credentials() {
        return this._credentials;
    }

    set authType(authType) {

        if ((authType && typeof authType == 'string') && (authType == 'basic' || authType == 'digest' || authType == 'bearer')) {
            this._authType = JSON.stringify(authType);
        } else if (typeof authType == 'object') {
            this._authType = (new util()).getValueFromTypedInput({ type: authType.mapVarType, value: authType.mapVarValue });
        } else if (typeof authType == 'string') {
            this._authType = authType
        } else {
            this._authType = undefined
        }

    }

    get authType() {
        return this._authType;
    }

    get cookies() {
        return this._cookies;
    }

    set cookies(cookies) {

        if (cookies instanceof Array) {
            this._cookies = '{'
            for (let i = 0; i < cookies.length; i++) {
                let cookieObj = cookies[i];

                if (cookieObj && cookieObj.name && cookieObj.hasOwnProperty('value') && cookieObj['value'].value && cookieObj['value'].value.length > 0) {
                    this._cookies += `"${cookieObj.name}" : {`

                    this._cookies += `"value": ${(new util()).getValueFromTypedInput(cookieObj['value'])}`;
                    this._cookies += ','
                    this._cookies += `"options": ${this.__getCookieOptions(cookieObj.options)}`;
                }
                this._cookies += '},'
            }
            this._cookies += '}'
        } else if (cookies && cookies.hasOwnProperty('type') && cookies.hasOwnProperty('value') && cookies.type && cookies.value) {
            this._cookies = (new util()).getValueFromTypedInput(cookies);
        } else {
            this._cookies = undefined;
        }
    }

    /**
     * Available options:
     * domain: string
     * expires: as is (This could be a date object)
     * httpOnly: boolean
     * maxAge: number
     * path: string
     * secure: boolean
     * signed: boolean https://stackoverflow.com/questions/11897965/what-are-signed-cookies-in-connect-expressjs
     * sameSite: 'lax' | 'strict' | 'none' https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
     * @param {*} options 
     */
    __getCookieOptions(options) {
        let snippet = '';
        if (this.__checkIfOptionExists(options.domain)) {
            snippet += `domain: '${options.domain}',\n`;
        }

        if (this.__checkIfOptionExists(options.expires)) {
            snippet += `expires: ${options.expires},\n`;
        }

        if (this.__checkIfOptionExists(options.httpOnly)) {
            snippet += `httpOnly: ${options.httpOnly},\n`;
        }

        if (this.__checkIfOptionExists(options.maxAge)) {
            snippet += `maxAge: ${options.maxAge},\n`;
        }

        if (this.__checkIfOptionExists(options.path)) {
            snippet += `path: '${options.path}',\n`;
        }

        if (this.__checkIfOptionExists(options.secure)) {
            snippet += `secure: ${options.secure},\n`;
        }

        if (this.__checkIfOptionExists(options.signed)) {
            snippet += `signed: ${options.signed},\n`;
        }

        if (this.__checkIfOptionExists(options.sameSite)) {
            snippet += `sameSite: '${options.sameSite}'`;
        }
        return this.__wrapInCurlyBraces(snippet);
    }

    __wrapInCurlyBraces(snippet) {
        return '{\n' + snippet + '\n}';
    }

    __checkIfOptionExists(option) {
        return typeof option === 'string' && option.length > 0;
    }

    get functionName() {
        return this._functionName;
    }

    set functionName(functionName) {
        this._functionName = functionName;
    }

    get method() {
        return this._method;
    }

    set method(method) {
        this._method = method;
    }

    get url() {
        return this._url;
    }

    set url(url) {
        this._url = url
    }

    get body() {
        return this._body ? this._body : undefined;
    }

    set body(body) {
        this._body = body;
    }

    get username() {
        return this._username ? this._username : undefined;
    }

    set username(username) {
        if (username) {
            this._username = (new util()).getValueFromTypedInput({ type: username.mapVarType, value: username.mapVarValue })

        }
    }

    get password() {
        return this._password ? this._password : undefined;
    }

    set password(password) {
        if (password) {
            this._password = (new util()).getValueFromTypedInput({ type: password.mapVarType, value: password.mapVarValue });
        }
    }

    get token() {
        return this._token ? this._token : undefined;
    }

    set token(token) {
        if (token) {
            this._token = (new util()).getValueFromTypedInput({ type: token.mapVarType, value: token.mapVarValue })
        }

    }

    get params() {
        return this._params;
    }

    set params(params) {
        this._params = params;
    }

    get headers() {
        return this._headers;
    }

    set headers(headers) {
        this._headers = headers;
    }

    set requestTimeout(requestTimeout) {

        if (requestTimeout && requestTimeout.hasOwnProperty('type') && requestTimeout.hasOwnProperty('value') && requestTimeout.value.length > 0) {
            this._requestTimeout = (new util()).getValueFromTypedInput(requestTimeout);
        } else {
            this._requestTimeout = 30000;//30 seconds as default
        }
    }

    get requestTimeout() {
        return this._requestTimeout;
    }

    get followRedirects() {
        return this._followRedirects;
    }

    set followRedirects(followRedirects) {
        if (typeof followRedirects === 'undefined') {
            this._followRedirects = true;
        }
        else {
            this._followRedirects = followRedirects;
        }
    }

    set rejectUnauthorized(rejectUnauthorized) {
        this._rejectUnauthorized = rejectUnauthorized;
    }
    get rejectUnauthorized() {
        return this._rejectUnauthorized;
    }

}