let { BaseComponent, SRDCodeGenUtil: util }  = require("@jatahworx/bhive-toolkits");
let pathToRegx = require('path-to-regexp');

// @paulthomas0 - note that httpOptions is used to
// generate swagger document, if required include
// more options to generate more elaborate swagger.json
module.exports = class HttpIn extends BaseComponent {
    constructor(constructorOptions) {
        super(constructorOptions.id, constructorOptions.name, "neutrinos_service_designer_http_in", "HttpIn");
        this.functionName = constructorOptions.functionName;
		this._util = new util();

        if (constructorOptions.httpOptions) {
            // http method - get, post, put.. etc...
            this.httpOptions = constructorOptions.httpOptions;
            // /path/:param
            this.path = this.__getPath(this.httpOptions);
            // /path/{param}
            this.swaggerPath = this.__replaceAsSwaggerPaths(pathToRegx.parse(this.path));
            // get|post|put|patch|delete
            this.method = this.__getMethodByPath(this.httpOptions, this.path);
            if (typeof this.method != 'string' || !this.method.match(/get|post|put|patch|delete/)) {
                throw new Error('Invalid http-in method type, should be get, post, put, patch or delete');
            }
            // sequenceId: a unique string identifying a middeware sequence
            this.sequenceId = constructorOptions.sequenceId;
        }
        if (constructorOptions.uploadFileOptions) {
            this.uploadOptions = constructorOptions.uploadFileOptions;
			if (constructorOptions.uploadFileOptions && constructorOptions.uploadFileOptions.path && constructorOptions.uploadFileOptions.path !== '""') {
				this.addImports = true;
			}
        }
        this.viewType = 'server';
        this.nodeType = BaseComponent.nodeTypes.START;
	}
	
	generateImports(rootPaths) {
		if(this.addImports) {
			return [
				{
					library: 'os',
					alias: 'os'
				},
				{
					library: 'path',
					modules: [
						'sep'
					]
				}
			]
		}
		return [];
	}

    generateSnippet() {
        const backtick = '`';
        const bsp = '${this.serviceBasePath}';
        const path = this.path.startsWith('/') ? this.path : '/' + this.path;
        const nodeSnippet = `
        if (!this.swaggerDocument['paths']['${this.swaggerPath}']) {
            this.swaggerDocument['paths']['${this.swaggerPath}'] = ${JSON.stringify(this.httpOptions[this.path])};
        } else {
            this.swaggerDocument['paths']['${this.swaggerPath}']['${this.method}'] = ${JSON.stringify(this.httpOptions[this.path][this.method])}
        }
        this.app['${this.method}'](${backtick}${bsp}${path}${backtick}, cookieParser(),
            this.sdService.getMiddlesWaresBySequenceId(${this.sequenceId ? JSON.stringify(this.sequenceId) : 'null'}, 'pre', this.generatedMiddlewares),
            ${this.uploadOptions && this.method == 'post' || this.uploadOptions && this.method == 'put' ? 'this.sdService.multipartParser(' + this.uploadOptions + '),' : ''} 
            async (req, res, next) => {
            let bh  = {};
            try {
                bh = this.sdService.__constructDefault({local: {}, input: {}}, req, res, next);
                //appendnew_next_${this.functionName}
            } catch (e) {
                return await this.errorHandler(bh, e, '${this.id}');
            }
		}, this.sdService.getMiddlesWaresBySequenceId(${this.sequenceId ? JSON.stringify(this.sequenceId) : 'null'}, 'post', this.generatedMiddlewares));`;
		return ({
			nodeSnippet,
			noWrap: true 
		});
    }

    __addResponses() {
        let responseString = "";
        return responseString;
    }

    getErrorTemplate() {
        return `
        export class errorCheck {
            sampleMethod() {
                //appendnew_node
            }
        }
        `;
    }

    __getPath(httpOptions) {
        let path = Object.getOwnPropertyNames(httpOptions)[0];
        return path;
    }

    __getMethodByPath(httpOptions, path) {
        let method = Object.getOwnPropertyNames(httpOptions[path])[0];
        return method;
    }

    __replaceAsSwaggerPaths(pathArr) {
        let ps = '';
        if (pathArr instanceof Array) {
            for (let i = 0; i < pathArr.length; i++) {
                if (typeof pathArr[i] == 'string') {
                    ps += `${pathArr[i].startsWith('/') ? '' : '/'}${pathArr[i]}`;
                } else if (typeof pathArr[i] == 'object') {
                    ps += `${pathArr[i].name.startsWith('/') ? '' : '/'}{${pathArr[i].name}}`;
                }
            }
        }
        return ps;
    }

    /**
     * uploadFileOptions: {
       type: 'path' | 'memory',
       path?: '/temp',
       fileOptions?: [{
        name: 'profile',
        maxCount?: 1
      }]
     * }
     */
    set uploadOptions(o) {
        this.__uploadOptions = null;
        if (o && Object.keys(o).length) {
            if (typeof o.type == 'string' && !o.type.match(/memory|path/)) {
                throw new Error('Upload options should of type memory or should specify a path to upload');
            }
            this.__uploadOptions = {};
            this.__uploadOptions.type = JSON.stringify(o.type);
            if (o.path && o.path !== '""') {
				this.__uploadOptions.path = `(${o.path}).replace(/\\\\|\\//g, sep)`;
            }
            if (o.fileOptions instanceof Array) {
                for (let i = 0; i < o.fileOptions.length; i++) {
                    if (!o.fileOptions[i].name) {
                        throw new Error('A file upload option should have a name and maxCount');
                    }
                }
                this.__uploadOptions.options = o.fileOptions;
                if (o.fileOptions.length === 0) {
                    delete this.__uploadOptions.options;
				}
                this.__uploadOptions.options = JSON.stringify(o.fileOptions);
            }
			this.__uploadOptions = this._util.getObjAsCodeString(this.__uploadOptions);
        }
    }

    get uploadOptions() {
        return this.__uploadOptions ? this.__uploadOptions : null;
	}
}

/**
 *
 {
        "id": "HttpInFunction",
        "type": "HttpIn",
        "z": "sd_qDrT01nOe14KuevW",
        "sequenceId": "sequence1",
        "uploadFileOptions": {
            "type": "path",
            "path": "/temp",
            "fileOptions": [
                {
                    "name": "profile",
                    "maxCount": 1
                }
            ]
        },
        "httpOptions": {
            "/pet": {
                "post": {
                    "summary": "Add a new pet to the store",
                    "description": "",
                    "consumes": [
                        "application/json"
                    ],
                    "produces": [
                        "application/json"
                    ],
                    "parameters": [
                        {
                            "in": "body",
                            "name": "body",
                            "description": "Pet object that needs to be added to the store",
                            "required": true
                        }
                    ],
                    "responses": {
                        "405": {
                            "description": "Invalid input"
                        }
                    }
                }
            }
        },
        "outputs": 1,
        "noerr": 0,
        "functionName": "functionname",
        "x": 72.20001220703125,
        "y": 76.93749237060547,
        "wires": [
            [
                "HttpRequestForImage"
            ]
        ]
    }
 */