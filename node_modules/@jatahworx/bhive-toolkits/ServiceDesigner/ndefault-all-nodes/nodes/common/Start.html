<script type="text/x-red" data-template-name="Start">
    <div class="editor-form-row">
        <input type="checkbox" id="node-input-accept_bh">
    </div> 
    <div id="input-props-section-container"  class="editor-form-row-margin-bottom-0">
        <label for="input-props-section"><span data-i18n="common.label.input-title"></span></label>
        <div id="input-props-section" class="props-section">
            <div class="add-section">
                <div class="srd-editableList-add-kv-wrp">
                    <input type="text" class="property-key">
                    <input type="text" class="property-value">
                </div>
                <div class="output-toggle-group">
                    <div class="output-toggle-label">Output</div>
                    <div class="toggle-button">
                        <label class="switch">
                            <input type="checkbox">
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
            </div>
            <div class="properties-container" validatesform="true">
                <ol id="input-properties-content"></ol>
            </div>
            <span class="list-keys-invalid">{{Editable List Invalid Message}}</span>
        </div>
    </div>
    <div id="local-props-section-container"  class="editor-form-row-margin-bottom-0">
        <label for="local-props-section"><span data-i18n="common.label.local-title"></span></label>
        <div id="local-props-section" class="props-section">
            <div class="add-section">
                <div class="srd-editableList-add-kv-wrp">
                    <input type="text" class="property-key">
                    <input type="text" class="property-value">
                </div>
                <div class="output-toggle-group">
                    <div class="output-toggle-label">Output</div>
                    <div class="toggle-button">
                        <label class="switch">
                            <input type="checkbox">
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
            </div>
            <div class="properties-container" validatesform="true">
                <ol id="local-properties-content"></ol>
            </div>
            <span class="list-keys-invalid">{{Editable List Invalid Message}}</span>
        </div>
    </div>
</script>

<script type="text/javascript">
    registerNode({
        nodeType: 'Start',
        nodeDef: {
            color: "#677BFC",
            category: 'General',
            shape: "circle",
			defaults: {
				name: { value: "" },
				outputs: { value: 1 },
				inputVariables: {},
				localVariables: {},
				accept_bh: { value: '' }
			},
            inputs: 0,
            outputs: 1,
            icon: "ndefault-all-nodes/start-node.svg",
            label: function () {
                return this.name || 'Start'
            },
            labelStyle: function () {
                return this.name ? "node_label_italic" : "";
            },
            oneditprepare: function (SRD) {
                let node = this;
                node.tempVarStore = { inputVariables: [], localVariables: [] };
                const valTypes = [
                    { value: 'str', label: 'string' },
                    { value: 'num', label: 'number', validate: SRD.validators.typedInput('num') },
                    'bool',
                    { value: 'null', label: 'null', constant: true },
                    { value: 'any', label: 'any' }
                ]
                const doneBtn = $('#node-dialog-ok');
                const form = $('#dialog-form');

                function populateExistingVariables(sectionName, variablesObjectArr) {
                    if (variablesObjectArr && variablesObjectArr instanceof Array) {
                        for (let row of variablesObjectArr) {
                            if (typeof row.defaultValue === 'string') {
                                row.defaultValue = {
                                    type: 'str',
                                    value: row.defaultValue
                                };
                            }
                            $(`#${sectionName}-properties-content`).editableList('addItem', { rowData: row, validator: false });
                        }
                    }
                }

				function keywordsValidator(val) {
					return ({
						valid: !val || !SRD.utils.isTSKeyWord(val),
						errorMessage: 'it\'s a reserved keyword!'
					})
				}

                function preparePropsSection(sectionName, dialogForm) {

                    /* Properties add section key-value fields */
                    let startKvWrp = $(`#${sectionName}-props-section .srd-editableList-add-kv-wrp`);
                    let keyField = $(`#${sectionName}-props-section .property-key`).inputField({
                        placeholder: SRD._('common.label.key'),
						validatorRegexp: /^[a-zA-Z][a-zA-Z_0-9]*$/,
						validator: keywordsValidator
                    });
                    let valueField = $(`#${sectionName}-props-section .property-value`).css({
                        margin: 'auto',
                        'margin-right': '1em',
                        width: '45%'
                    }).typedInput({
						types: valTypes,
						default: 'any',
                        noErrorElement: false
                    });

                    /* Output toggle section */
                    let outputToggle = $(`#${sectionName}-props-section .output-toggle-group`);

                    /* Properties List */
                    let propertiesContainer = $(`#${sectionName}-props-section .properties-container`);
                    let invalidListMsg = $(`#${sectionName}-props-section .list-keys-invalid`).css({ 'visibility': 'hidden' });

                    let propertiesHeaderContainer = $(`<div class="properties-header-container"></div>`).prependTo(propertiesContainer);

                    let headers = $(`
                <div class="editableList-header start-elHeader" style="left: 2%;">No.</div>
                <div class="editableList-header start-elHeader" style="left: 9%;">Key</div>
                <div class="editableList-header start-elHeader" style="left: 40%;">Value</div>
                <div class="editableList-header start-elHeader" style="left: 82%">Output</div>
                `).appendTo(propertiesHeaderContainer);

                    let varArrType = sectionName === 'input' ? 'inputVariables' : 'localVariables';

                    function updateTempVarStore(prop, val, currentRowIdArr, setRest) {
                        for (let i in node.tempVarStore[varArrType]) {
                            if (currentRowIdArr.includes(node.tempVarStore[varArrType][i]['rowId'])) {
                                node.tempVarStore[varArrType][i][prop] = val;
                                if (setRest === undefined) {
                                    return i;
                                }
                            } else if (setRest !== undefined) {
                                node.tempVarStore[varArrType][i][prop] = setRest;
                            }
                        }
                    }

                    function ultimateValidator() {
						SRD.defaults.validateForm(SRD.validators.editableList(propertiesContainer, propsContent, {
                            checkUniquenessOn: node.tempVarStore[varArrType].map(x => x.key),
                            checkValidityOn: node.tempVarStore[varArrType],
                            errorMsgContainer: invalidListMsg
                        }));
                    }

                    let propsContent = $(`#${sectionName}-properties-content`).data({ valid: true, isUnique: true, isValid: true });
                    propsContent.editableList({
                        addItem: function (container, i, data) {
                            let rowData = data.rowData || { defaultValue: {} };
                            let dataObj = {
                                key: rowData.key || keyField.val(),
                                defaultValue: {
                                    type: rowData.defaultValue.type || valueField.typedInput('type'),
                                    value: rowData.defaultValue.value || valueField.typedInput('value')
                                },
                                output: rowData.output || $(outputToggle.find('input')).prop('checked'),
                                rowId: rowData.rowId || SRD.nodes.id(),
                                valid: true
                            };
                            node.tempVarStore[varArrType].push(dataObj);
                            container.attr('id', dataObj.rowId).data('data', { rowData: dataObj });

                            /* property list's "key" field */
                            let listKey = $(`<input type="text"/>`).appendTo(container).inputField({
                                wrapperAttr: { style: 'width: 30%;' },
                                validatorRegexp: /^[a-zA-Z][a-zA-Z_0-9]*$/,
								inputClassList: "property-key",
								validator: keywordsValidator,
                                value: dataObj.key || keyField.val(),
                                updations: function (elemData, inputVal) {
                                    let index = updateTempVarStore('key', inputVal, container.data().data.rowData.rowId);
                                    node.tempVarStore[varArrType][index].valid = listKey.inputField('valid') && listVal.typedInput('valid');
                                    container.data('data', { rowData: node.tempVarStore[varArrType][index] });
                                    ultimateValidator();
                                }
                            });

                            function changeHandler(evt) {
                                if (listVal.data('srdTypedInput')) {
                                    const val = {
                                        type: listVal.typedInput('type'),
                                        value: listVal.typedInput('value'),
                                    };
                                    let index = updateTempVarStore('defaultValue', val, container.data('data').rowData.rowId);
                                    node.tempVarStore[varArrType][index].valid = listKey.inputField('valid') && listVal.typedInput('valid');
                                    container.data('data', { rowData: node.tempVarStore[varArrType][index] });
                                    ultimateValidator();
                                }
                            }
                            /* property list's "defaultValue" field */
                            let listVal = $(`<input type="text"/>`).css({ width: '40%' }).appendTo(container).typedInput({
                                types: valTypes,
                                noErrorElement: false,
                                onvalchanged: changeHandler
                            }).change(changeHandler)

                            let v = Object.assign({}, dataObj.defaultValue);
                            listVal.typedInput('type', v.type);
                            listVal.typedInput('value', v.value);

                            /* property list's "output" toggle button */
                            let listToggle = outputToggle.clone().appendTo(container);
                            listToggle.find(`.output-toggle-label`).remove(); // Remove the output toggle label
                            let listToggleInputElm = listToggle.find('input');
                            listToggleInputElm.prop('checked', dataObj.output || listToggleInputElm.prop('checked'))
                                .on('input', function (event) {
                                    let index = updateTempVarStore('output', $(event.target).prop('checked'), container.data().data.rowData.rowId);
                                    container.data('data', {
                                        rowData: node.tempVarStore[varArrType][index]
                                    });
                                });

                            propertiesContainer.show();
                            $('.property-row .field-floating-placeholder').remove();

                            /* Clear the "Add" Section input fields */
                            keyField.inputField('reset');
                            valueField.typedInput('value', '');
                            outputToggle.find('input').prop('checked', false);

                        },
                        removable: true,
                        scrollOnAdd: true,
                        removeItem: function (data) {
                            node.tempVarStore[varArrType] = node.tempVarStore[varArrType].filter(vObj => vObj['rowId'] !== data.rowData.rowId);
                            ultimateValidator();
                            if (node.tempVarStore[varArrType].length === 0) {
                                $(`#${sectionName}-props-section .properties-container`).hide();
                            }
                        },
                        showAddBtnLabel: false,
                        validator: function () {
                            let keyToValidate = keyField.val();
                            if (!keyToValidate.match(keyField.inputField('option', 'validatorRegexp'))) {
                                SRD.dialogService.openSnackBar('Key invalid. key should start with an alphabet and can contain alphabets, numbers, underscore.');
                                return false;
                            }
                            if (!valueField.typedInput('validate')) {
                                SRD.dialogService.openSnackBar('Invalid Value for the Type Selected');
                                return false;
                            }
                            if (node.tempVarStore[varArrType].find(vObj => vObj['key'] === keyToValidate)) {
                                SRD.dialogService.openSnackBar('Duplicate key. This key already exists.');
                                return false
                            }
                            return true;
                        }
                    });
                }

                /* Add input and local properties section */
                preparePropsSection('input');
                preparePropsSection('local');

                /* Hide the properties list by default. It will be displayed whenever 'addItem' runs */
                $('#local-props-section .properties-container').hide();
                $('#input-props-section .properties-container').hide();

                /* Populate editableList with the variables if already present */
                populateExistingVariables('input', this.inputVariables);
                populateExistingVariables('local', this.localVariables);

                /* Reposition the "Add" button */
                $('.add-prop-btn-wrp').each(function (i, elem) {
                    $(elem).css({ 'margin-left': '0.5em' })
                        .appendTo($('.add-section')[i]);
                });

                $('#node-input-accept_bh').toggleButton({
                    label: 'Accept flow object',
                    cssObject: { width: 'fit-content' },
                    desciption: 'When turned on, uses the bh object of the calling flow. Otherwise, creates a new bh object for this flow.',
                    afterToggle: function (value) {
                        if (value) {
                            $('[id$=-props-section-container]').hide();
                        } else {
                            $('[id$=-props-section-container]').show();
                        }
						SRD.defaults.validateForm(true);
                    }
                });

            },
            oneditsave: function () {
                /* Update the "inputVariables", "localVariables", "functionName" to the node */
                this.inputVariables = this.tempVarStore.inputVariables.map(x => ({ key: x.key, defaultValue: x.defaultValue, output: x.output }));
                this.localVariables = this.tempVarStore.localVariables.map(x => ({ key: x.key, defaultValue: x.defaultValue, output: x.output }));
                delete this.tempVarStore;
            },
            oneditcancel: function () {
                delete this.tempVarStore;
            },
            aftereditsave: function (changes) {
                if (this.accept_bh) {
                    if (this.inputVariables && this.inputVariables.length) {
                        changes.inputVariables = this.inputVariables;
                        delete this.inputVariables;
                    }
                    if (this.localVariables && this.localVariables.length) {
                        changes.localVariables = this.localVariables;
                        delete this.localVariables;
                    }
                }
                return changes;
            },
            docsLink: 'start-node'
        }
    });
</script>
<script type="text/x-red" data-help-name="Start">
</script>