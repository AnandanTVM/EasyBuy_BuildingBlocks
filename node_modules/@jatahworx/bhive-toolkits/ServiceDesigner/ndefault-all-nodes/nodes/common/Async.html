<script type="text/x-red" data-template-name="Async">
    <div class="editor-form-row margin-bottom-0" style="margin-top: 1.5em;">
        <label for="node-input-typed-resultMapping">Result Mapping</label>
        <input id="node-input-typed-resultMapping" style="width: 100%;">
    </div>
    
    <div class="editor-form-row">
        <label for="node-service-picker">Select a Flow</label>
        <div id="node-service-picker" style="width:99%;"></div>
    </div>
    <div id="btn-placeholder"></div>
    
    <!-- <label class="editor-form-row-label" for="flow-selector">Flows to be called</label>
    <div id="flow-selector">
        <div style="width: 50%;">
            <select id="node-select-service" class="select-service-field" style="width: 99%; position: relative; text-align: center;"></select>
            <div id="select-service-error" class="error-msg-container"><span class="invalid-select">Select a service</div>
        </div>
        <div style="width: 50%;">
            <select id="node-select-flow" class="select-flow-field" style="width: 99%; position: relative; text-align: center;"></select>
            <div id="select-flow-error" class="error-msg-container"><span class="invalid-select">Select a flow</div>
        </div>
    </div> -->
    
    <div class="editor-form-row properties-container" style="border: none; margin-top: 1em;">
        <div id="node-flow-container"></div>
    </div>
    </script>
<script type="text/javascript">
    registerNode({
        nodeType: "Async",
        nodeDef: {
            defaults: {
                name: { value: "" },
                flowNodes: { value: [], validate: (v) => !!v.length },
                _flowNodes: { value: [] },
                resultMapping: { value: '', required: true }
            },
            inputs: 1,
            outputs: 1,
            icon: "ndefault-all-nodes/async-block-node.svg",
            color: '#951CF4',
            paletteLabel: 'Async',
            category: 'Function',
            label: function () {
                return this.name || 'Async';
            },
            labelStyle: function () {
                return this.name ? "node_label_italic" : "";
            },
            usedServiceIds: function (S) {
                return this.flowNodes.map(v => v.serviceId) || [];
            },
            onserviceusersupdate: function (S, { action, id }) {
                if (action === 'delete-workspace') {
                    this.flowNodes = this._flowNodes.filter(n => n.serviceId !== id);
                } else if (this.flowNodes instanceof Array && this.flowNodes.length) {
                    for (let i = 0; i < this._flowNodes.length; i++) {
                        this.flowNodes[i].relativePath = S.utils.getRelativePathFrom(this.z, this.flowNodes[i].serviceId);
                    }
                }
                this._flowNodes = this.flowNodes.slice();
            },
            oneditinit: function (SRD) {
                let node = this;
                let serviceList = [];
                let flowsList = [];
                let startNodesArr = [];
                let allNodes = [];

                // variables to assign new start node inputs
                let selectedFlowsArr = [];
                let isResultMappingValid;

                // Function Declarations
                function getServiceList() {
                    let workspaceObj = SRD.workspaces.getAll({ excludeMiddleWares: true });
                    let workspaceIds = workspaceObj.map(v => v.id);
                    for (let i = 0; i < workspaceIds.length; i++) {
                        serviceList.push({ value: workspaceIds[i], displayValue: workspaceObj[i].label })
                        allNodes[workspaceIds[i]] = SRD.nodes.workspaceNodes('Start', null, null, workspaceIds[i]).nodesArr.map(flow => {
                            const fnName = SRD.utils.getFnName(flow);
                            return {
                                serviceId: workspaceIds[i],
                                serviceName: workspaceObj[i].label,
                                flowId: flow.id,
                                flowName: flow.name || fnName,
                                functionName: SRD.utils.getFnName(flow),
                                inputParams: flow.inputParams ? flow.inputParams.slice() : [],
                                inputVariables: flow.inputVariables ? flow.inputVariables.slice() : [],
                                accept_bh: flow.accept_bh ? flow.accept_bh : false
                            }
                        });
                    }
                    if (node.flowNodes && node.flowNodes.length) {
                        node._flowNodes = [];
                        for (let flow of node.flowNodes) {
                            let elem = null;
                            if (Array.isArray(allNodes[flow.serviceId])) {
                                elem = allNodes[flow.serviceId].find(f => (f.flowId === flow.flowId))
                            }
                            if (elem) {
                                if (elem.accept_bh !== flow.accept_bh) {
                                    selectedFlowsArr.push(elem);
                                    node._flowNodes.push(elem);
                                }
                                else {
                                    let elemInput = elem.inputVariables.map(e => (e.key));
                                    let flowInput = flow.inputVariables.map(e => (e.key));
                                    let arr = elemInput.filter(a => (!flowInput.includes(a)));
                                    if ((flow.inputParams && !flow.inputParams.length) || (elemInput && (flowInput.length !== elemInput.length))) {
                                        selectedFlowsArr.push(elem);
                                        node._flowNodes.push(elem);
                                    }
                                    else {
                                        selectedFlowsArr.push(flow);
                                        node._flowNodes.push(elem);
                                    }
                                }
                            }
                        }
                    }
                    validateAllInputs();
                }

                function getStartNodesList(workspaceId) {
                    flowsList = allNodes[workspaceId].map(flow => ({
                        value: flow.flowId,
                        displayValue: flow.flowName,
                        functionName: flow.functionName
                    }));
                }

                function updateFlowsList(item) {
                    let elem = $('#node-service-picker').flowPicker('getSelectedFlow');
                    let service = $('#node-service-picker').flowPicker('getSelectedFlowService');
                    if (elem && elem.id && elem.z) {
                        // duplicating keys to avoid massive code change for 7.4.0
                        elem.flowId = elem.id;
                        elem.serviceId = elem.z;
                        elem.serviceName = service.label;

                        selectedFlowsArr.push(elem);
                        node._flowNodes.push(elem);
                        SRD.dialogService.openSnackBar(`${elem.functionName} was successfully added to the list.`);
                    }

                }

                function getNwInputVariables(inputVars) {
                    let nwInputAttrArr = [];
                    let nodeInputVars = selectedFlowsArr.find(f => (f.inputVariables === inputVars));
                    let oldInputAttrArr = nodeInputVars ? nodeInputVars.inputVariables : [];

                    nwInputAttrArr = inputVars.map(function (elem1) {
                        let tempElem2;
                        let isElePresent = oldInputAttrArr.some(function (elem2) {
                            tempElem2 = elem2;
                            return (elem1.key === elem2.key);
                        });
                        if (isElePresent && tempElem2.value) {
                            return tempElem2;
                        } else {
                            return { key: elem1.key, value: '', map: true, valueType: 'bh', mapVarType: 'input' };
                        }
                    });
                    return nwInputAttrArr;
                }

                function getInputVariablesByServiceNFlow(serviceId, flowId) {
                    if (selectedFlowsArr && selectedFlowsArr.length) {
                        let inputVar = selectedFlowsArr.find(f => (f.serviceId === serviceId && f.flowId === flowId));
                        if (inputVar && inputVar.inputVariables) {
                            return getNwInputVariables(inputVar.inputVariables);
                        }
                    }
                    else {
                        let inputVar = allNodes[serviceId].find(flow => (flow.flowId === flowId));
                        if (inputVar && inputVar.inputVariables) {
                            return inputVar.inputVariables;
                        }
                    }
                }

                function fillVariables(propsContent, variablesObjectArr, tableType) {
                    if (variablesObjectArr && variablesObjectArr instanceof Array) {
                        if (tableType === 'sublist') {
                            for (let row of variablesObjectArr)
                                propsContent.editableList('addItem', { rowData: row, validator: false });
                        }
                        else if (tableType === 'list') {
                            for (let row of variablesObjectArr) {
                                getStartNodesList(row.serviceId);
                                propsContent.editableList('addItem', row);
                            }
                        }
                    }
                }

                const bhTypeValidator = SRD.validators.typedInput('bh', true);
                function validateResultMapping(value) {
                    isResultMappingValid = bhTypeValidator(value);
                    validateAllInputs();
                    return isResultMappingValid;
                }

                function validateAllInputs() {
                    const valid = selectedFlowsArr.length && isResultMappingValid;
                    if (!valid) {
                        $('#node-dialog-ok').addClass('disabled');
                    } else {
                        $('#node-dialog-ok').removeClass('disabled');
                    }
                    return valid;
                }

                getServiceList(); // Getting services and flows

                //initializing fields
                $('#node-input-typed-resultMapping').typedInput({
                    types: [
                        { value: 'bh', label: 'bh.', validate: validateResultMapping },
                        { value: 'bh.input', label: 'bh.input.', validate: validateResultMapping },
                        { value: 'bh.local', label: 'bh.local.', validate: validateResultMapping },
                    ],
                    noformvalidation: true
                });

                $('#node-service-picker').flowPicker({
                    onTreeInit: (ctx) => { },
                    // selectedFlow: node?.flow?.flowId, 
                    onNodeSelect: (data, selectingSelectedFlow) => {
                        if (data.flownode && !selectingSelectedFlow) {
                            $('.add-prop-btn-wrp').find('.add-prop-btn').css({ 'pointer-events': 'inherit' });
                        }
                    },
                    srd: SRD
                })

                let OrderList = $('#node-flow-container').css({ "min-width": "400px", "list-style-type": "none" }).data({ isValid: true, isUnique: true });
                let propsContainer = $('.properties-container').css({ 'margin-bottom': '0' });
                propsContainer.hide();


                OrderList.editableList({
                    addItem: function (container, opt, rowItem, miscElms) {
                        propsContainer.show();
                        container.css({
                            height: '100%',
                            whiteSpace: 'nowrap',
                            'flex-wrap': 'wrap',
                            'justify-content': 'space-between',
                            'padding-bottom': '0.5em',
                            'margin-top': '1.5em',
                            'background': 'white'
                        });

                        let serviceValue, flowValue, rowObj = rowItem || {};

                        if (!Object.keys(rowObj).length) {
                            const f = $('#node-service-picker').flowPicker('getSelectedFlow');
                            const s = $('#node-service-picker').flowPicker('getSelectedFlowService')
                            rowObj.flowId = f.id;
                            rowObj.serviceId = s.id;
                            rowObj.serviceName = s.label;
                        }

                        updateFlowsList(rowObj);
                        let tempObj = selectedFlowsArr.find(f => (f.serviceId === rowObj.serviceId && f.flowId === rowObj.flowId))
                        Object.assign(rowObj, tempObj);
                        let row = $('<div/>', { style: "width: 100%;" }).appendTo(container);
                        let innerRow = $('<div/>', { style: "display: flex;" }).addClass('row').appendTo(row)
                        let innerRow2 = $('<div/>', { style: "width: 99%;" }).appendTo(container);
                        $(`<div class="editor-form-row-label" style="width: 48%; margin-left: 0.2em;">Service : ${rowObj.serviceName}</div>`).appendTo(innerRow);
                        $(`<div class="editor-form-row-label" style="width: 50%;">Flow : ${rowObj.functionName}</div>`).appendTo(innerRow);

                        let inputVarContainer = $(`
                                    <div class="editor-form-row-margin-bottom-0 node-input-var-container properties-container"></div>
                                `).appendTo(innerRow2);

                        if (tempObj.inputVariables && tempObj.inputVariables.length && !tempObj.accept_bh) {
                            let inputList = $(`<ol id="node-input-var-${rowObj.serviceId}-${rowObj.flowId}"></ol>`).appendTo(inputVarContainer);
                            let propsHeaderContainer = $(`<div class="properties-header-container"></div>`, { style: "display: flex;" }).css({ 'margin-top': '2%' }).insertBefore(inputList);
                            let headers = $(`
                                    <div class="header">No.</div>
                                    <div class="wide-header">Key</div>
                                    <div style="margin-left: 1.5em" class="wide-header">Value</div>
                                    <div style="margin-right: 1.5em;" class="header map-header">Map</div>
                                `).appendTo(propsHeaderContainer);

                            inputList.editableList({
                                addItem: function (container, i, data) {
                                    let rowData = data.rowData || {};
                                    let outputToggle = `<div class="output-toggle-group" style="margin-right: 0.5em;">
                                            <div class="output-toggle-label">Map</div>
                                            <div class="toggle-button">
                                                <label class="switch">
                                                    <input id ="mapping-input-${rowObj.serviceId}-${rowObj.flowId}-${rowData.key}" type="checkbox">
                                                    <span class="slider round"></span>
                                                </label>
                                            </div>
                                        </div>`;

                                    /* property list's "key" field */
                                    let listKey = $(`<input type="text"/>`).appendTo(container);
                                    listKey.inputField({
                                        attrs: { style: 'width: 80%; margin-left: 1em;' },
                                        inputClassList: "property-key",
                                        props: { readonly: true },
                                        value: rowData ? `bh.input.${rowData.key}` : null,
                                    });

                                    let valueElementTypedInput = `
                                        <div class="form-row field-wrapper-typedInput">
                                            <input type="text" class="node-input-property input-width" style="width: 99% !important; margin-top: 1em;"/>
                                            <input type="hidden" id="node-typedInput-${rowObj.flowId}-${rowData.key}"/>
                                        </div>`
                                    // input element is used to create value filed in input properties table and type section in the output table
                                    let valueElement = `<input type="text" class="node-input-property" id="value-input-${rowObj.flowId}-${rowData.key}" style="width: 99% !important; margin-top: 1em;">`;
                                    let listVal;
                                    let listValInput;
                                    let valueElementTypedInputObj = $(valueElementTypedInput).css({ flex: 'unset' }).appendTo(container);
                                    listVal = valueElementTypedInputObj.find('.node-input-property').typedInput({
                                        types: [
                                            { value: "bh", label: 'bh.', validate: SRD.validators.typedInput('bh') },
                                            { value: "bh.input", label: 'bh.input.', validate: SRD.validators.typedInput('bh.input') },
                                            { value: "bh.local", label: 'bh.local.', validate: SRD.validators.typedInput('bh.local') }
                                        ]
                                    });

                                    if (rowData.valueType) {
                                        listVal.typedInput('type', rowData.valueType);
                                        listVal.typedInput('value', rowData.value);
                                    }
                                    /* property list's "value" field */
                                    let dataObj = {};

                                    // $('<span class="callservice-mapping-direction-arrows">&#x2190;</span>').appendTo(listKey.parent());
                                    listValInput = $(valueElement).appendTo(container).inputField({
                                        inputClassList: "property-value",
                                        value: !rowData.map ? rowData.value || rowData.value : '',
                                        wrapperClass: rowData.map ? 'display-none value-input' : 'value-input'
                                    });
                                    if (!rowData.map) {
                                        valueElementTypedInputObj.addClass('display-none');
                                    }
                                    /* property list's "output" toggle button */
                                    let listToggle = $(outputToggle).appendTo(container);
                                    listToggle.find(`.output-toggle-label`).remove(); // Remove the output toggle label
                                    let listToggleInputElm = listToggle.find('input');

                                    listToggleInputElm.prop('checked', rowData.map || listToggleInputElm.prop('checked')).on('input', function (event) {
                                        if ($(event.target).prop('checked')) {
                                            $(`#${container.data().data.rowData.rowId}`).children('.field-wrapper-typedInput').removeClass('display-none')
                                            listVal.typedInput('type', 'bh.input');
                                            $(`#${container.data().data.rowData.rowId}`).children('.value-input').addClass('display-none')
                                        } else {
                                            $(`#${container.data().data.rowData.rowId}`).children('.value-input').removeClass('display-none')
                                            $(`#${container.data().data.rowData.rowId}`).children('.field-wrapper-typedInput').addClass('display-none')
                                        }
                                    });

                                    dataObj.map = listToggleInputElm.prop('checked')
                                    dataObj.key = listKey.val();
                                    // change value 
                                    dataObj.value = listVal.val();
                                    dataObj.rowId = rowData.rowId || SRD.nodes.id();
                                    dataObj.valid = true;

                                    container.attr('id', dataObj.rowId).data('data', { rowData: dataObj });
                                    $(`#${dataObj.rowId}`).find('.field-wrapper.value-input').css({ width: '90%', 'margin-top': '0.25em' });
                                    $('.property-row .field-floating-placeholder').remove();
                                    $('.properties-container .wide-header').width($('.properties-container .field-wrapper').width()).css({ 'margin-left': 0 });
                                    $('.add-prop-btn-wrp').find('.add-prop-btn').css({ 'pointer-events': 'none' });
                                    validateAllInputs();
                                }
                            });
                        }
                        else {
                            let noInputMsg = $(`
                                    <div> 
                                        <h4> No Inputs </h4> 
                                    </div>
                                `).css({
                                'display': 'flex',
                                'justify-content': 'center',
                                'align-items': 'center'
                            }).appendTo(inputVarContainer);
                            $('.add-prop-btn-wrp').find('.add-prop-btn').css({ 'pointer-events': 'none' });
                            validateAllInputs();
                        }

                        if (miscElms.deleteBtn) {
                            miscElms.deleteBtn.attr('class', 'switch-delete-icon');
                            miscElms.deleteBtn.css({ 'right': '2.5em', 'top': '-0.2em' });
                        }
                        if (miscElms.sortableHandle) {
                            miscElms.sortableHandle.css({ 'width': '1em', 'right': '1em' });
                        }

                        let inputVars = getInputVariablesByServiceNFlow(rowObj.serviceId, rowObj.flowId);
                        if (inputVars && inputVars.length && !tempObj.accept_bh) {
                            fillVariables($(`#node-input-var-${rowObj.serviceId}-${rowObj.flowId}`), inputVars, 'sublist');
                            let listParent = $(`#node-input-var-${rowObj.serviceId}-${rowObj.flowId}`).parent('.red-ui-editableList-container');
                            listParent.next('.add-prop-btn-wrp').remove();
                        }
                        container.attr('id', `node-row-${rowObj.serviceId}-${rowObj.flowId}`).data('data', rowObj);
                        // $('.editor-tray-body-wrapper').scrollTop($('.editor-tray-body-wrapper').height())
                    },
                    removeItem: function (itemData) {
                        if (itemData) {
                            let idx = selectedFlowsArr.findIndex(f => (f.serviceId === itemData.serviceId && f.flowId === itemData.flowId));
                            if (idx !== -1) {
                                selectedFlowsArr.splice(idx, 1);
                                node._flowNodes.splice(idx, 1);
                                if (!selectedFlowsArr.length) {
                                    propsContainer.hide();
                                }
                            }
                        }
                        validateAllInputs();
                    },
                    sortItems: function (items) {
                        let tempArr = [];
                        for (let item of items) {
                            let id = item[0].id.split('-');
                            let servId = id[id.length - 2], flowId = id[id.length - 1];
                            let flowVal = selectedFlowsArr.find(f => (f.serviceId === servId && f.flowId === flowId));
                            if (flowVal)
                                tempArr.push(flowVal);
                        }
                        selectedFlowsArr = [];
                        selectedFlowsArr = tempArr.slice();
                        node._flowNodes = tempArr.slice();
                    },
                    sortable: true,
                    removable: true,
                    validator: function () {
                        let f = $('#node-service-picker').flowPicker('getSelectedFlow');
                        const s = $('#node-service-picker').flowPicker('getSelectedFlowService');
                        let serviceId = s?.id;
                        let flowId = f?.id;
                        if (selectedFlowsArr.length) {
                            if (serviceId && flowId) {
                                if (!selectedFlowsArr.find(f => (f.serviceId === serviceId && f.flowId === flowId))) {
                                    return true;
                                }
                                SRD.dialogService.openSnackBar(`Duplicate Entry. The flow already exists`);
                                return false;
                            }
                            return true;
                        }
                        else {
                            if (serviceId && flowId) {
                                return true;
                            }
                            SRD.dialogService.openSnackBar('Invalid values');
                            return false;
                        }
                    }
                });

                fillVariables(OrderList, selectedFlowsArr, 'list');
                // let flowSelector = $("#flow-selector").css({ width: 'inherit', display: 'flex' });
                $('.red-ui-editableList-container').attr('style', 'max-height : 15em !important; overflow-y: unset;');
                $('.add-prop-btn-wrp').css({ 'margin-top': '0.5em' }).insertAfter($('#btn-placeholder'));
                $('.add-prop-btn-wrp').find('.add-prop-btn').css({ 'pointer-events': 'none' });
                $(document).ready(function () {
                    validateAllInputs();// validate initial data 
                });
            },
            oneditsave: function (SRD) {
                let node = this;
                node.flowNodes = node._flowNodes.slice();
                for (let iter in this.flowNodes) {
                    if (!node.flowNodes[iter].accept_bh) {
                        let inputNodes = [];
                        let inputParamsArr = [];
                        $(`#node-input-var-${node.flowNodes[iter].serviceId}-${node.flowNodes[iter].flowId}`).editableList('items').each(function (i) {
                            let inputObj = {};
                            let row = $(this);
                            inputObj.key = (row.find('.property-key').val()).substring('bh.input.'.length);
                            inputObj.map = (row).find(`#mapping-input-${node.flowNodes[iter].serviceId}-${node.flowNodes[iter].flowId}-${inputObj.key}`).prop('checked');

                            if (row.find(`.field-wrapper-typedInput.display-none`).length) {
                                let value = (row).find('.property-value').val();
                                inputObj.value = value;
                                inputParamsArr.push(value ? value : null);
                            } else {
                                let valueType = row.find(".node-input-property").typedInput('type');
                                let value = row.find(".node-input-property").typedInput('value');
                                inputObj.valueType = valueType;
                                inputObj.value = value;
                                if (inputObj.value.length > 0) {
                                    inputParamsArr.push(`${valueType}.${value}`);
                                }
                                else {
                                    inputParamsArr.push(null);
                                }
                            }
                            inputNodes.push(inputObj);
                        });
                        node.flowNodes[iter].inputVariables = inputNodes;
                        node.flowNodes[iter].inputParams = inputParamsArr;
                    }
                    node.flowNodes[iter].relativePath = SRD.utils.getRelativePathFrom(this.z, node.flowNodes[iter].serviceId)
                }
            },
            oneditresize: function (SRD) {
                $('.properties-container .wide-header').width($('.properties-container .field-wrapper').width()).css({ 'margin-left': 0 });
            },
            docsLink: 'async-node'
        }
    })
</script>