let BaseComponent = require("@jatahworx/bhive-toolkits").BaseComponent;

module.exports = class AsyncBlock extends BaseComponent {
    constructor(constructorOptions) {
        super(constructorOptions.id, constructorOptions.name, "neutrinos_service_designer_async", "Async");
        this.flowNodes = constructorOptions.flowNodes;
        this.resultMapping = constructorOptions.resultMapping;
        this.viewType = 'common';
        this.z = constructorOptions.z;
    }

    get flowNodes() {
        return this._flowNodes;
    }

    set flowNodes(flowNodes) {
        this._flowNodes = flowNodes;
    }

    get resultMapping() {
        return this._resultMapping;
    }

    set resultMapping(resultMapping) {
        this._resultMapping = resultMapping;
    }

    generateFlowTemplate(serviceType) {
        let flowTemplate = ``;
        if(serviceType === BaseComponent.viewTypes.SERVER) {
            for(let flow of this.flowNodes) {
                const theCall = (flow.serviceId === this.z) ? 
                `const ${flow.serviceId}Instance: ${flow.serviceName} = ${flow.serviceName}.getInstance();\n` : 
                `const ${flow.serviceId}Instance: ${flow.serviceId}.${flow.serviceName} = ${flow.serviceId}.${flow.serviceName}.getInstance();\n`;
                if(!flowTemplate.includes(theCall)) {
                    flowTemplate +=  theCall
                    if(flow.accept_bh) {
                        flowTemplate += `promiseArray.push(${flow.serviceId}Instance.${flow.functionName}(bh));\n`;
                    }
                    else {
                        flowTemplate += `promiseArray.push(${flow.serviceId}Instance.${flow.functionName}(${this.__formatInputParams(flow.inputParams)}));\n`;
                    }
                }
                else {
                    if(flow.accept_bh) {
                        flowTemplate += `promiseArray.push(${flow.serviceId}Instance.${flow.functionName}(bh));\n`;
                    }
                    else {
                        flowTemplate += `promiseArray.push(${flow.serviceId}Instance.${flow.functionName}(${this.__formatInputParams(flow.inputParams)}));\n`;
                    }
                }
            }
        }
        else {
            for(let flow of this.flowNodes) {
                let functionCall = (flow.serviceId === this.z) ? `this.${flow.functionName}` : `this.${flow.serviceId}.${flow.functionName}`;
                if(flow.accept_bh) {
                    flowTemplate += `promiseArray.push(${functionCall}(bh));\n`;
                }
                else {
                    flowTemplate += `promiseArray.push(${functionCall}(${this.__formatInputParams(flow.inputParams)}));\n`;
                }
            }
        }
        return flowTemplate;
    }

	generateSnippet(serviceType) {
		const snippet = `let promiseArray = [];
			${this.generateFlowTemplate(serviceType)}
			${this.resultMapping} =  await Promise.all(promiseArray);`;
		return snippet;
	}

    generateImports(rootPaths) {
        let importArray = [];
        console.log('this.flowNodes', this.flowNodes)
        importArray = this.flowNodes.map(flow => {
            if(flow.serviceId !== this.z) {
                return ({
                    library: flow.relativePath,
                    alias: flow.serviceId
                    // modules: [ flow.serviceName ]
                })
            }
        }).filter(val => (val));
        return importArray;
    }

    updateTemplate(serviceClassTemplate, serviceType) {
        if(serviceType === BaseComponent.viewTypes.CLIENT) {
            for(let flow of this.flowNodes) {
                if(flow.serviceId !== this.z) {
                    let constructorInit = 'constructor(';
                    const injectStr = `private ${flow.serviceId} : ${flow.serviceId}.${flow.serviceName}`;
                    let injectionArr = this.getAllInjections(serviceClassTemplate);
                    if (injectionArr && !injectionArr.includes(injectStr)) {
                        constructorInit = `constructor(${injectStr},`;
                    }
                    serviceClassTemplate = serviceClassTemplate.replace("constructor(", constructorInit);
                }
            }
        }
        return serviceClassTemplate;
    }

    getAllInjections(serviceClassTemplate) {
        let regx = new RegExp('constructor\(.*\)');
        if (typeof serviceClassTemplate === 'string') {
            let ms = serviceClassTemplate.match(regx);
            if (ms && ms.length) {
                let m = ms[0];
                return m.replace('constructor(', '').replace(')', '').split(',').map(v => v.trim());
            }
        }
        return null;
    }

    __formatInputParams(inputParams) {
        let formattedParams = "";
        if (inputParams instanceof Array) {
            for (let i = 0; i < inputParams.length; i++) {
                formattedParams += `${inputParams[i]},`;
            }
            formattedParams = formattedParams.substring(0, formattedParams.length - 1);
        }
        return formattedParams;
    }
}