// import * as nodemailer from 'nodemailer';
import * as POP3Client from 'poplib';
import * as MailParser from 'mailparser';
import * as Imap from 'imap';

let EmailServiceInstance: EmailInService = null;
let __simpleParser: any;
export class EmailInService {
    // private __simpleParser: any;

    constructor() {}

    static getInstance(): EmailInService {
        if (!EmailServiceInstance) {
            
            EmailServiceInstance = new EmailInService();
            __simpleParser = MailParser.simpleParser;
        }
        return EmailServiceInstance;
    }

    getEmails(serverOptions: {
        server: string,
        port: number
    }, emailOptions: {
        maxCount?: number
        box: string,
        useSSL: boolean,
        protocol: string,
        disposition: string,
        criteria: any,
        userid: string,
        password: string,
        tls: boolean,
        imapTimeouts?: {
            authTimeout: number,
            connectionTimeout: number
        }
    }) {
        return new Promise((resolve, reject) => {
            if (typeof emailOptions.maxCount != 'number') {
                emailOptions.maxCount = 100;
            }

            if (!serverOptions.server || !serverOptions.port) {
                return reject(new Error('Server configuration missing for listening to a email box. Please, provide host(server) and port'));
            }

            emailOptions.box = emailOptions.box || 'INBOX';
            emailOptions.protocol = emailOptions.protocol || 'IMAP';
            emailOptions.disposition = emailOptions.disposition || 'None'; // 'None', 'Delete', 'Read'
            emailOptions.criteria = emailOptions.criteria || ['UNSEEN']; // 'ALL', 'ANSWERED', 'FLAGGED', 'SEEN', 'UNANSWERED', 'UNFLAGGED', 'UNSEEN'

            if (emailOptions.protocol == 'POP3') {
                this.checkPOP3(serverOptions.port, serverOptions.server, emailOptions.useSSL, emailOptions.userid, emailOptions.password)
                    .then(result => {
                        return resolve(result);
                    })
                    .catch(error => {
                        return reject(error);
                    })
            } else if (emailOptions.protocol == 'IMAP') {
                this.checkIMAP({
                    box: emailOptions.box,
                    criteria: emailOptions.criteria,
                    disposition: emailOptions.disposition,
                    host: serverOptions.server,
                    port: serverOptions.port,
                    password: emailOptions.password,
                    userid: emailOptions.userid,
                    imapTimeouts: emailOptions.imapTimeouts,
                    tls: emailOptions.tls,
                    maxCount: emailOptions.maxCount
                }).then(result => {
                    return resolve(result);
                }).catch(error => {
                    return reject(error);
                })
            } else {
                return reject(new Error('Illegal protocol requested for sending emails.'));
            }
        });
    }

    private checkIMAP(emailOptions: {
        userid: string,
        password: string,
        host: string,
        port: number,
        imapTimeouts: {
            authTimeout: number,
            connectionTimeout: number
        },
        tls?: boolean,
        box: string,
        criteria: string,
        disposition: string,
        maxCount: number
    }) {
        return new Promise((resolve, reject) => {
            let emails = [];
            let baseServiceInstance = this;
            let imap = new Imap({
                user: emailOptions.userid,
                password: emailOptions.password,
                host: emailOptions.host,
                port: emailOptions.port,
                connTimeout: emailOptions.imapTimeouts.connectionTimeout,
                authTimeout: emailOptions.imapTimeouts.authTimeout,
                tls: emailOptions.tls,
                tlsOptions: {
                    rejectUnauthorized: false
                }
            })

            imap.on('error', function (err) {
                if (err.errno !== 'ECONNRESET') {
                    return reject(new Error('Email status: Connection error.'));
                }
                return reject(err);
            })

            imap.once('ready', function () {
                imap.openBox(emailOptions.box,
                    false,
                    function (err, box) {
                        if (err) {
                            return reject(err);
                        }
                        let criteria = emailOptions.criteria;
                        imap.search(criteria, function (err, results) {
                            if (err) {
                                return reject(err);
                            } else {
                                if (results.length == 0) {
                                    imap.end();
                                    return resolve();
                                }
                                let marks = false;
                                if (emailOptions.disposition == 'Read') {
                                    marks = true;
                                }

                                let fetch = imap.fetch(results, {
                                    bodies: '',
                                    struct: true,
                                    markSeen: marks
                                });

                                fetch.on('message', function (imapMessage, seqno) {
                                    imapMessage.on('body', function (stream, info) {
                                        baseServiceInstance.__simpleParser(stream, {}, function (err, parsed) {
                                            if (err) {
                                                return reject(err);
                                            } else {
                                                emails.push(parsed);
                                                if (emailOptions.maxCount == emails.length) {
                                                    imap.end();
                                                    return resolve(emails);
                                                }
                                            }
                                        })
                                    })
                                });

                                fetch.on('end', function () {
                                    let cleanup = function () {
                                        imap.end();
                                        return resolve(emails);
                                    }

                                    if (emailOptions.disposition == 'Delete') {
                                        imap.addFlags(results, '\nDeleted', cleanup);
                                    } else if (emailOptions.disposition == 'Read') {
                                        imap.addFlags(results, '\nSeen', cleanup);
                                    } else {
                                        cleanup();
                                    }
                                });

                                fetch.once('error', function (err) {
                                    return reject(err);
                                })
                            }
                        });
                    })
            })

            imap.connect();
        })
    }

    private checkPOP3(port, server, useSSL, userid, password) {
        return new Promise((resolve, reject) => {
            let baseServiceInstance = this;
            let pop3Client = new POP3Client(port, server, { enabletls: useSSL });
            pop3Client.on('stat', function (status, data) {
                if (status) {

                } else {
                    return reject(new Error('email stat error ' + status + ' ' + data));
                }
            });

            pop3Client.on('connect', function () {
                pop3Client.login(userid, password);
            });

            pop3Client.on('login', function (status, rawData) {
                if (status) {
                    pop3Client.stat();
                } else {
                    pop3Client.quit();
                    return reject(new Error('Login failed'));
                }
            });

            pop3Client.on('retr', function (status, msgNumber, data, rawData) {
                if (status) {
                    baseServiceInstance.__simpleParser(data, {}, function (err, parsed) {
                        pop3Client.dele(msgNumber);
                        if (err) {
                            return reject(err);
                        } else {
                            return resolve(parsed);
                        }
                    })
                } else {
                    pop3Client.quit();
                    return reject(new Error('Retr failed'));
                }
            })

            pop3Client.on('invalid-state', function (cmd) {
                return reject(new Error('Invalid state: ' + cmd));
            })

            pop3Client.on('locked', function (cmd) {
                return reject(new Error('We were locked: ' + cmd));
            })

            pop3Client.on('dele', function (status, msgNumber) {
                return reject(new Error('Dele happend'));
            })
        });
    }

}