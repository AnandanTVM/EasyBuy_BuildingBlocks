let BaseComponent = require("@jatahworx/bhive-toolkits").BaseComponent;
let statusCodes = require('http-status-codes');

module.exports = class GlobalMongoSession extends BaseComponent {
    constructor(constructorOptions) {
        super(constructorOptions.id, constructorOptions.name, "neutrinos_service_designer_GlobalMongoSession", "GlobalMongoSession");
        this.functionName = constructorOptions.id;
        this.viewType = BaseComponent.viewTypes.SERVER;
        // express-session options
        // cookie
        this.cookie = {
            domain: constructorOptions.cookieDomain,
            secure: constructorOptions.cookieSecure,
            expires: constructorOptions.cookieExpires,
            httpOnly: constructorOptions.cookieHttpOnly,
            maxAge: constructorOptions.cookieMaxAge,
			path: constructorOptions.cookiePath,
            sameSite: constructorOptions.cookieSameSite
        };
        // name - optional
        // proxy - optional [true, false, undefined]
        this.proxy = constructorOptions.proxy;
        // resave - required [true, false]
        this.resave = constructorOptions.resave;
        // rolling - optional [true, false]
        this.rolling = constructorOptions.rolling;
        // saveUninitialized - required [true, false]
        this.saveUninitialized = constructorOptions.saveUninitialized;
        // secret - required [string]
        this.secret = constructorOptions.secret;
        // store - optional [Database Name | undefined]
        this.dbConnectionName = constructorOptions.dbConnectionName;
        // unset - optional [keep, destroy]
        this.unset = constructorOptions.unset;
        this.autoremove = constructorOptions.autoremove;


        this.errorMapping = constructorOptions.errorMapping;
        this.dbConnectionId = constructorOptions.db

        if (this.errorMapping && this.errorMapping.status) {
            let statuses = Object.values(statusCodes);
            if (!statuses.includes(this.errorMapping.status)) {
                throw new Error('Response status is not a valid status number.');
            } 
        }
        this.nodeType = BaseComponent.nodeTypes.MIDDLEWARE;
    }

    generateImports(rootPaths) {
        return [
            {
                library: 'express-session',
                alias: 'expressSession',
            },
            {
                library: rootPaths.pathToUtilsRoot + '/ndefault-mongodb/Mongodb/MongoConnections',
                modules: [
                    'MongoConnections'
                ]
            },
            {
                library: 'neutrinos-mongodb-session-store',
                alias: 'mongoconnector'
            }
        ]
    }

	generateSnippet() {
		return {
			nodeSnippet: `let sess: expressSession.SessionOptions = {
                ${this.cookie}
                ${this.proxy}
                ${this.resave}
                ${this.rolling}
                ${this.saveUninitialized}
                ${this.secret}
                ${this.unset}
                ${this.__getStoreTemplate()}
            }
			return expressSession(sess);`,
			async: false
		};
	}

    set cookie(cookie) {
        let c = '{';
        if (cookie.domain) {
            c += 'domain: ' + `"${cookie.domain}",`
        }
        if (typeof cookie.secure === 'boolean') {
            c += 'secure: ' + `${cookie.secure},`;
        }
        if (cookie.expires) {
            c += 'expires: ' + `${cookie.expires},`;
        }
        if (typeof cookie.httpOnly === 'boolean') {
            c += 'httpOnly: ' + `${cookie.httpOnly},`;
        }
        if (cookie.path) {
            c += 'path: ' + `"${cookie.path}",`;
        }

        if (cookie.maxAge) {
            c += 'maxAge: ' + `${cookie.maxAge},`;
		}
		
		if (cookie.sameSite) {
            c += `sameSite: ${cookie.sameSite}`;
        }

        c += '}'
        this.__cookie = c;
    }

    get cookie() {
        if (typeof this.__cookie == 'string' && this.__cookie.length) {
            return `
                cookie: ${this.__cookie},
            `
        }
        return '';
    }

    set proxy(proxy) {
        this.__proxy = proxy;
    }

    get proxy() {
        let v = this.__bool(this.__proxy);
        if (v.length) {
            return `
                proxy: ${v},
            `
        }
        return '';
    }

    set resave(resave) {
        this.__resave = resave;
    }

    get resave() {
        let v = this.__bool(this.__resave);
        if (v.length) {
            return `
                resave: ${v},
            `
        }
        return '';
    }

    set rolling(rolling) {
        this.__rolling = rolling;
    }

    get rolling() {
        let v = this.__bool(this.__rolling);
        if (v.length) {
            return `
                rolling: ${v},
            `
        }
        return '';
    }

    set saveUninitialized(saveUninitailzed) {
        this.__saveUninitialized = saveUninitailzed;
    }

    get saveUninitialized() {
        let v = this.__bool(this.__saveUninitialized);
        if (v.length) {
            return `
             saveUninitialized: ${v},
            `
        }
        return '';
    }

    set secret(secret) {
        this.__secret = secret;
    }

    get secret() {
        if (!this.__secret) throw new Error('Invalid Session options. secret is required.');
        return `
            secret: ${this.__secret},
        `
    }

    set dbConnectionName(dbConnectionName) {
        this.__dbConnectionName = dbConnectionName;
    }

    get dbConnectionName() {
        return this.__dbConnectionName || '';
    }

    set dbConnectionId(dbConnectionId) {
        this.__dbConnectionId = dbConnectionId;
    }

    get dbConnectionId() {
        return this.__dbConnectionId || '';
    }

    __getStoreTemplate() {
        if (!this.dbConnectionName) return '';
        let store = `
            store: new (mongoconnector(expressSession))({
                client: MongoConnections.getInstance().getMongoInstance('${this.dbConnectionId}'),
                autoRemove: '${this.autoremove}'
             
        `
        if (this.autoremoveInterval) {
            store = store + `autoRemoveInterval: ${this.autoRemoveInterval}`
        }

        store = store + ' })'

        return store;
    }

    set unset(unset) {
        this.__unset = unset;
    }

    get unset() {
        if (this.__unset && !['keep', 'destroy'].includes(this.__unset)) throw new Error('Invalid options for global mongo session. unset can only be keep or destroy');
        return `
            unset: '${this.__unset}',
        `
    }


    set autoremove(autoremove) {
        // console.log('autoremove', autoremove);
        this.__autoremove = autoremove;
    }

    get autoremove() {
        // console.log(this.__autoremove, !['initial', 'destroy', 'interval'].includes(this.__autoremove))
        // if (this.__autoremove && !['initial', 'destroy', 'interval'].includes(this.__autoremove)) throw new Error('Invalid options for global mongo session. unset can only be initial or destroy or interval');
        return  this.__autoremove;
    }

    set autoRemoveInterval(autoRemoveInterval) {
        this.__autoremoveInterval = autoRemoveInterval;

    }

    get autoRemoveInterval() {
        return this.__autoremoveInterval;
    }

    __bool(b) {
        return typeof b == 'boolean' ? JSON.stringify(b) : '';
    }

    get error() {
        let e = 'throw e;';
        if (this.errorMapping && this.errorMapping.status && this.errorMapping.send) {
            e = 'bh.web.next({ status: ' + this.errorMapping.status + ', send: ' + this.errorMapping.send + ' })';
        }
        return e;
    }

    getErrorTemplate() {
        return `
        let c = {
            //appendnew_node
        }
        `;
    }
}
