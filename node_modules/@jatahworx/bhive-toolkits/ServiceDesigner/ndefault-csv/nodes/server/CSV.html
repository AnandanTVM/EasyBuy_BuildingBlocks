<script type="text/x-red" data-template-name="CSV">
    <!-- Type of operation -->
    <div class="editor-form-row">
        <label for="node-select-operation"><span data-i18n="common.label.operation-type"></span></label>
        <select id="node-select-operation" style="width: 100%;"></select>
    </div>

    <!-- csv source -->
    <div id="node-input-csv-source-wrp" class="editor-form-row">
        <label for="node-input-csv-source"><span data-i18n="csv-parser.label.csv-source"></span></label>
        <input type="text" id="node-input-csv-source" class="node-input-property" style="width: 100%" />
    </div>

    <!-- csv switch -->
    <div id="node-input-csv-switch-wrp" class="output-toggle-group editor-form-row padding-top-0 margin-bottom-0" >
        <div class="parser-switch-toggle-label">Switch</div>
        <div class="toggle-button">
            <label class="switch">
                <input id="csv-switch-check" type="checkbox">
                <span class="slider round"></span>
            </label>
        </div>
    </div>

    <!-- parsed csv -->
    <div id="node-input-parsed-csv-wrp" class="editor-form-row">
        <label for="node-input-parsed-csv"><span data-i18n="csv-parser.label.parsed-csv"></span></label>
        <input type="text" id="node-input-parsed-csv" class="node-input-property" style="width: 100%" />
    </div>
    
    <!-- Header toggle -->
    <div id="node-input-header-wrp" class="output-toggle-group">
        <div class="parser-switch-toggle-label">Header</div>
        <div class="toggle-button">
            <label class="switch">
                <input id="header-check" type="checkbox">
                <span class="slider round"></span>
            </label>
        </div>
    </div>
    
    <!-- Column  editable list -->
    <div id="column-props-section-container">
        <label for="column-props-section"><span  data-i18n="csv-parser.label.column"></span></label>
        <div id="column-props-section" class="props-section">
            <div class="add-section">
                <div class="srd-editableList-add-kv-wrp">
                    <input type="text" class="property-key">
                    <input type="text" class="property-value">
                </div>
            </div>
            <div class="properties-container" validatesform="true">
                <ol id="column-properties-content"></ol>
            </div>
            <span class="list-keys-invalid">{{Editable List Invalid Message}}</span>
        </div>
    </div>

    <!-- Parse options -->

    <!-- Headers -->
    <div id="key-props-section-container" class="editor-form-row margin-bottom-0">
        <div style="display: flex">
            <label for="key-props-section">
                <span class="props-title" data-i18n="csv-parser.label.column"></span>
            </label>
        </div>
        
        <!-- Parse columns toggle -->
        <div id="node-input-parse-col-wrp" class="output-toggle-group editor-form-row padding-top-0 margin-bottom-0 ">
            <div class="fileout-toggle-label">Parse Columns</div>
            <div class="toggle-button">
                <label class="switch">
                    <input id="parse-col-check" type="checkbox">
                    <span class="slider round"></span>
                </label>
            </div>
            <button class="map-button-wrp" style="padding-bottom: 1em;">
                <image id="node-input-parse-col-button" class="map-button proxy-map-value-toggle-headers" title="Map Keys" src="assets/icons/edit.svg">
            </button>
        </div>

        <div id="key-props-section" class="props-section editor-form-row margin-bottom-0" >
            <div class="add-section headers-section" style="align-items: baseline;">
                <div class="srd-editableList-add-kv-wrp">
                    <input type="text" class="property-key" name="headers-key">
                </div>
                
                <button class="map-button-wrp keymap-button" style="margin-left: 0em; display:flex; justify-content: flex-end;">
                    <image id="node-input-filepath-button" class="map-button proxy-map-value-toggle-headers" title="Parse Columns" src="assets/icons/edit.svg">
                </button>
            </div>
            <div class="properties-container" validatesform="true">
                <ol id="key-properties-content"></ol>
            </div>
            <span class="list-keys-invalid">{{Editable List Invalid Message}}</span>
        </div>
    </div>

    <!-- Delimeter -->
    <div id="node-select-delimeter-wrp" class="editor-form-row">
        <label for="node-input-delimeter" ><span data-i18n="csv-parser.label.delimeter"></span></label>
        <select id="node-input-delimeter" style="width: 100%;"></select>
        <div id="node-input-delimeter-other-wrp">
            <input type="text" id="node-input-delimeterother">
        </div>
    </div>

    <!-- Max record size -->
    <div id="node-input-record-size-wrp" class="editor-form-row">
        <input type="text" id="node-input-maxrecordsize">
    </div>

    <!-- Relax column size toggle-->
    <div id="node-input-col-size-wrp" class="output-toggle-group editor-form-row margin-bottom-0 padding-top-0" >
        <div class="fileout-toggle-label">Relax Column Size</div>
        <div class="toggle-button">
            <label class="switch">
                <input id="col-size-check" type="checkbox">
                <span class="slider round"></span>
            </label>
        </div>
    </div>

    <!-- skip lines with error toggle-->
    <div id="node-input-skip-lines-wrp" class="output-toggle-group editor-form-row padding-top-0 margin-bottom-0">
        <div class="fileout-toggle-label">Skip lines with error</div>
        <div class="toggle-button">
            <label class="switch">
                <input id="skip-lines-check" type="checkbox">
                <span class="slider round"></span>
            </label>
        </div>
    </div>

    <!-- byte order mark toggle-->
    <div id="node-input-byte-order-wrp" class="output-toggle-group editor-form-row padding-top-0 margin-bottom-0" >
        <div class="fileout-toggle-label">Byte order mark</div>
        <div class="toggle-button">
            <label class="switch">
                <input id="byte-order-check" type="checkbox">
                <span class="slider round"></span>
            </label>
        </div>
    </div>
    
</script>



<script type="text/javascript">
    registerNode({
        nodeType: 'CSV',
        serviceType: 'server',
        nodeDef: {
            color: "#99d101",
            category: 'Parser',
            defaults: {
                name: {
                    value: ''
                },
                operationType: {
                    value: 'parse'
                },
                columns: {},
                delimeter: { value: '' },
                delimeterother: { },
                header: { value: false },
                csvsource: { value: ''  , required: true },
                csvswitch: { value: false },
                parsedcsv: {  },
                keyVariables: {},
                parsecolumns: { value: false },
                maxrecordsize: { value: 0 },
                relaxcolumnsize: { value: false },
                skiplines: { value: false },
                byteordermark: { value: false },
                colparsetogglestate : { value : true},
                outputs: {
                    value: 1
                },
                headers: { value: [] }
            },
            inputs: 1,
            outputs: 1,
            icon: "ndefault-csv/csv-node.svg",
            paletteLabel: function (def) {
                return 'CSV';
            },
            label: function () {
                return this.name || 'CSV'
            },
            labelStyle: function () {
                return this.name ? "node_label_italic" : "";
            },
            oneditprepare: function (SRD) {
                const form = $('#dialog-form');
                const node = this;
                const doneBtn = $('#node-dialog-ok');
                node.tempVarStore = { columnVariables: [], keyVariables: [] };
                const commonTypes = [
                    {
                        value: 'bh',
                        label: 'bh.',
                        validate: /[^\s]+/
                    },
                    {
                        value: 'bh.input',
                        label: 'bh.input.',
                        validate: /[^\s]+/
                    },
                    {
                        value: 'bh.local',
                        label: 'bh.local.',
                        validate: /[^\s]+/
                    },
                ]
                var resultTypes = [
                    {
                        value: 'bh',
                        label: 'bh.',
                        validate: fieldvalidation, nullable: true, nullableValue: 'undefined'
                    },
                    {
                        value: 'bh.input',
                        label: 'bh.input.',
                        validate: fieldvalidation, nullable: true, nullableValue: 'undefined'
                    },
                    {
                        value: 'bh.local',
                        label: 'bh.local.',
                        validate: fieldvalidation, nullable: true, nullableValue: 'undefined'
                    },
                ]
                function fieldvalidation (v) {
                    if (!document.querySelector('input[id="csv-switch-check"]').checked) {
                            return /[^\s]+/.test(v);
                        } 
                }
                $('#node-input-parse-col-wrp').hide();
                $('#node-input-filepath-button').on('click', function () {
                    if (node.colparsetogglestate) {
                        $('#key-props-section').hide();
                        $('#node-input-parse-col-wrp').show();
                    } else {
                        $('properties-container').remove();
                        $('#key-props-section').show();
                        $('#node-input-parse-col-wrp').hide();
                    }
					node.colparsetogglestate = !node.colparsetogglestate;
					validateForm();
                })
                $('#node-input-parse-col-button').on('click', function () {
                    if (!node.colparsetogglestate) {
                        $('properties-container').remove();
                        $('#key-props-section').show();
                        $('#node-input-parse-col-wrp').hide();
                    } else {
                        $('#key-props-section').hide();
                        $('#node-input-parse-col-wrp').show();
                    }
					node.colparsetogglestate = !node.colparsetogglestate;
					validateForm();
                })

                $('#csv-switch-check').on('change', function () {
                    if (document.querySelector('input[id="csv-switch-check"]').checked) {
                        $('#node-input-parsed-csv-wrp').hide();
                    } else {
                        $('#node-input-parsed-csv-wrp').show();
                        $('#node-input-parsed-csv').typedInput('validate');
                    }
                    validateForm();
                });
                const nodeName = $(`#node-input-name`).inputField();

                const nodecsvdelimeter = $(`#node-input-delimeterother`).inputField({
                    value: node.delimeterother,
                    placeholder: SRD._('n-sd:csv-parser.label.delimeterother')
                });
                const noderecordsize = $(`#node-input-maxrecordsize`).inputField({
					value: node.adConfigId,
					noformvalidation: false,
                    placeholder: SRD._('n-sd:csv-parser.label.reocrd-size'),
                    validatorRegexp: /^[0-9]*$/,
                    errorText: 'Enter a valid integer value'
                });
                /* Result Mapping field */
                const csvsource = $('#node-input-csv-source').typedInput({
					types: commonTypes,
					noformvalidation: false,
                    default: 'bh.input'
                });
                /* parsed csv field */
                const parsedcsv = $('#node-input-parsed-csv').typedInput({
                    types: resultTypes,
					noformvalidation: false,
                });

                function preparePropsSection(sectionName, dialogForm) {

                    /* Properties add section key-value fields */
                    let startKvWrp = $(`#${sectionName}-props-section .srd-editableList-add-kv-wrp`);
                    let keyField = $(`#${sectionName}-props-section .property-key`).inputField({
                    placeholder: SRD._(`n-sd:csv-parser.label.key`),
                    validatorRegexp: /^[a-zA-Z][a-zA-Z_0-9]*$/
                    });
                    let headerField
                    if (!dialogForm) {
                        headerField = $(`#${sectionName}-props-section .property-value`).inputField({
                        placeholder: SRD._('n-sd:csv-parser.label.header'),
                        validatorRegexp: /^[a-zA-Z][a-zA-Z_0-9]*$/
                        });
                    } else {
                    keyField = $(`#${sectionName}-props-section .property-key`).inputField({
                    wrapperAttr: { style: 'width: 95%;' },
                    placeholder: SRD._(`n-sd:csv-parser.label.key`),
                    validatorRegexp: /^[a-zA-Z][a-zA-Z_0-9]*$/
                    });
                    }

                    /* Properties List */
                    let propertiesContainer = $(`#${sectionName}-props-section .properties-container`);
                    let invalidListMsg = $(`#${sectionName}-props-section .list-keys-invalid`).css({ 'visibility': 'hidden'
                    });

                    let propertiesHeaderContainer = $(`<div class="properties-header-container"></div>
                    `).prependTo(propertiesContainer);
                    let headers;
                    if (!dialogForm) {
                        headers = $(`
                        <div class="editableList-header start-elHeader" style="left: 2%;">No.</div>
                        <div class="editableList-header start-elHeader" style="left: 9%;">Key</div>
                        <div class="editableList-header start-elHeader" style="left: 51%;">Header</div>
                        `).appendTo(propertiesHeaderContainer);
                    } else {
                        headers = $(`
                        <div class="editableList-header start-elHeader" style="left: 2%;">No.</div>
                        <div class="editableList-header start-elHeader" style="left: 7%;">Key</div>
                        `).appendTo(propertiesHeaderContainer);  
                    }

                    let varArrType = sectionName === 'column' ? 'columnVariables' : 'keyVariables';
                    function updateTempVarStore(prop, val, currentRowIdArr, setRest) {
                    for (let i in node.tempVarStore[varArrType]) {
                    if (currentRowIdArr.includes(node.tempVarStore[varArrType][i]['rowId'])) {
                    node.tempVarStore[varArrType][i][prop] = val;
                    if (setRest === undefined) {
                    return i;
                    }
                    } else if (setRest !== undefined) {
                    node.tempVarStore[varArrType][i][prop] = setRest;
                    }
                    }
                    }

					function validateEditableList() {
						SRD.defaults.validateForm(SRD.validators.editableList(propertiesContainer, propsContent, {
							checkUniquenessOn: node.tempVarStore[varArrType].map(x => x.key),
							checkValidityOn: node.tempVarStore[varArrType],
							errorMsgContainer: invalidListMsg
						}));
					}
                    let propsContent = $(`#${sectionName}-properties-content`).data({ valid: true, isUnique: true, isValid:
                    true });
                    if (!dialogForm) {

                        propsContent.editableList({
                            addItem: function (container, i, data) {
                            let rowData = data.rowData || {};
                            let dataObj = {
                            key: rowData.key || keyField.val(),
                            header: rowData.header || headerField.val() || '',
                            rowId: rowData.rowId || SRD.nodes.id(),
                            valid: true
                            };
                            node.tempVarStore[varArrType].push(dataObj);
                            container.attr('id', dataObj.rowId).css('align-items', 'center').data('data', { rowData: dataObj });
        
                            /* property list's "content-type" field */
                            let listKey = $(`<input type="text" />`).appendTo(container).inputField({
                            wrapperAttr: { style: 'width: 40%;' },
                            validatorRegexp: /^[a-zA-Z][a-zA-Z_0-9]*$/,
                            inputClassList: "property-key",
                            value: dataObj.key || keyField.val(),
                            updations: function (elemData, inputVal) {
								let key = updateTempVarStore('key', inputVal, container.data().data.rowData.rowId);
								node.tempVarStore[varArrType][key].valid = listVal.inputField('valid') && elemData.valid;
								container.data('data', { rowData: node.tempVarStore[varArrType][key] });
								validateEditableList();
                            }
                            });
                            
                            /* property list's "header" field */
                            let listVal = $(`<input type="text" />`).appendTo(container).inputField({
                            wrapperAttr: { style: 'width: 40%;' },
                            validatorRegexp: /^[a-zA-Z][a-zA-Z_0-9]*$/,
                            inputClassList: "property-key",
                            value: dataObj.header || headerField.val() || '',
                            updations: function (elemData, inputVal) {
									let header = updateTempVarStore('header', inputVal, container.data().data.rowData.rowId);
									node.tempVarStore[varArrType][header].valid = listKey.inputField('valid') && elemData.valid;
									container.data('data', { rowData: node.tempVarStore[varArrType][header] });
									validateEditableList();
								}
							});
        
                            function changeHandler(evt) {
                                if (listVal.data('srdTypedInput')) {
                                    const val = {
                                        type: listVal.typedInput('type'),
                                        value: listVal.typedInput('value'),
                                    };
                                    let index = updateTempVarStore('defaultValue', val, container.data('data').rowData.rowId);
                                    node.tempVarStore[varArrType][index].valid = listVal.typedInput('validate');
                                    container.data('data', { rowData: node.tempVarStore[varArrType][index] });
                                    validateEditableList();
                                }
                            }
        
                            propertiesContainer.show();
                            $('.property-row .field-floating-placeholder').remove();
        
                            /* Clear the "Add" Section input fields */
                            keyField.inputField('reset');
                            headerField.inputField('reset');
        
                            },
                            removable: true,
                            scrollOnAdd: true,
                            removeItem: function (data) {
                                node.tempVarStore[varArrType] = node.tempVarStore[varArrType].filter(vObj => vObj['rowId'] !==
                                data.rowData.rowId);
                                validateEditableList();
                                if (node.tempVarStore[varArrType].length === 0) {
                                    $(`#${sectionName}-props-section .properties-container`).hide();
                                }
                            },
                            showAddBtnLabel: false,
                            validator: function () {
                                let keyToValidate = keyField.val();
                                if (!keyToValidate.match(keyField.inputField('option', 'validatorRegexp'))) {
                                    SRD.dialogService.openSnackBar('Content-type Invalid! Key Should Start with an Alphabet and Can Contain Alphabets, Numbers, Underscore.');
                                    return false;
                                }
                                let headerToValidate = headerField.val();
                                if (!headerToValidate.match(headerField.inputField('option', 'validatorRegexp'))) {
                                    SRD.dialogService.openSnackBar('Header Invalid! Key Should Start with an Alphabet and Can Contain Alphabets, Numbers, Underscore.');
                                    return false;
                                }
                                if (node.tempVarStore[varArrType].find(vObj => vObj['key'] === keyToValidate)) {
                                    SRD.dialogService.openSnackBar('Duplicate Key! This Key Already Exists.');
                                    return false
                                }
                                return true;
                            }
                        });
                    } else {
                        propsContent.editableList({
                            addItem: function (container, i, data) {
                            let rowData = data.rowData || {};
                            let dataObj = {
                            key: rowData.key || keyField.val(),
                            rowId: rowData.rowId || SRD.nodes.id(),
                            valid: true
                            };
                            node.tempVarStore[varArrType].push(dataObj);
                            container.attr('id', dataObj.rowId).css('align-items', 'center').data('data', { rowData: dataObj });

                            /* property list's "content-type" field */
                            let listKey = $(`<input type="text" />`).appendTo(container).inputField({
                            wrapperAttr: { style: 'width: 90%;' },
                            validatorRegexp: /^[a-zA-Z][a-zA-Z_0-9]*$/,
                            inputClassList: "property-key",
                            value: dataObj.key || keyField.val(),
                            updations: function (elemData, inputVal) {
                            let index = updateTempVarStore('key', inputVal, container.data().data.rowData.rowId);
                            node.tempVarStore[varArrType][index].valid = elemData.valid;
                            container.data('data', { rowData: node.tempVarStore[varArrType][index] });
                            validateEditableList();
                            }
                            });
                            
                            
                            propertiesContainer.show();
                            $('.property-row .field-floating-placeholder').remove();

                            /* Clear the "Add" Section input fields */
                            keyField.inputField('reset');

                            },
                            removable: true,
                            scrollOnAdd: true,
                            removeItem: function (data) {
                                node.tempVarStore[varArrType] = node.tempVarStore[varArrType].filter(vObj => vObj['rowId'] !==
                                data.rowData.rowId);
                                validateEditableList();
                                if (node.tempVarStore[varArrType].length === 0) {
                                    $(`#${sectionName}-props-section .properties-container`).hide();
                                }
                            },
                            showAddBtnLabel: false,
                            validator: function () {
                                let keyToValidate = keyField.val();
                                if (!keyToValidate.match(keyField.inputField('option', 'validatorRegexp'))) {
                                    SRD.dialogService.openSnackBar('Content-type Invalid! Key Should Start with an Alphabet and Can Contain Alphabets, Numbers, Underscore.');
                                    return false;
                                }
                                if (node.tempVarStore[varArrType].find(vObj => vObj['key'] === keyToValidate)) {
                                    SRD.dialogService.openSnackBar('Duplicate Key! This Key Already Exists.');
                                    return false
                                }
                                return true;
                            }
                        });
                    }
                }

                function populateExistingVariables(sectionName, variablesObjectArr) {
                    if (variablesObjectArr && variablesObjectArr instanceof Array) {
                        for (let row of variablesObjectArr) {
                            $(`#${sectionName}-properties-content`).editableList('addItem', { rowData: row, validator: false });
                        }
                    }
                }

				function validateForm() {
					SRD.defaults.validateForm(true);
                }
                preparePropsSection('column');
                preparePropsSection('key','a');

                $('#column-props-section .properties-container').hide();
                $('#key-props-section .properties-container').hide();

                populateExistingVariables('column', this.columns);

                $('.add-prop-btn-wrp').each(function (i, elem) {
                    $(elem).css({ 'margin-left': '0.5em' })
                        .appendTo($('.add-section')[i]);
                });

                 /* Reposition the "Add" for key editable list button */
                 $('.add-prop-btn-wrp').each(function (i, elem) {
                     if (i!=0) {
                         $(elem).css('margin-left', '0.5em')
                             .insertBefore($('.add-section .map-button-wrp')[0]);
                     }
                });
                

                /* Select the type of operation. */
                const operationType = $('#node-select-operation').selectField({
                    optionsData: [
                        {
                            value: 'stringify',
                            displayValue: 'Builder'
                        },
                        {
                            value: 'parse',
                            displayValue: 'Parse'
                        }
                    ],
                    value: node.operationType,
                    change: (val) => {
                        $('#node-input-header-wrp').hide();
                        $('#column-props-section-container').hide();
                        $('#node-input-record-size-wrp').hide();
                        $('#node-input-col-size-wrp').hide();
                        $('#node-input-skip-lines-wrp').hide();
                        $('#node-input-byte-order-wrp').hide();
                        $('#key-props-section-container').hide();
                        if (val === 'stringify') {
                            $('#column-props-section-container').show();
                            $('#node-input-header-wrp').show();
                        } else {
                            $('#node-input-record-size-wrp').show();
                            $('#node-input-col-size-wrp').show();
                            $('#node-input-skip-lines-wrp').show();
                            $('#node-input-byte-order-wrp').show();
                            $('#key-props-section-container').show();
                        }
                        validateForm();
                    }
                });
                

                operationType.selectField('change', node.operationType);

                const delimeter = $('#node-input-delimeter').selectField({
                    optionsData: [
                    {
                            value: ',',
                            displayValue: 'Comma'
                        },
                        {
                            value: '"\t"',
                            displayValue: 'Tab'
                        },
                        {
                            value: '" "',
                            displayValue: 'Space'
                        },
                        {
                            value: ';',
                            displayValue: 'Semicolon'
                        },
                        {
                            value: ':',
                            displayValue: 'Colon'
                        },
                        {
                            value: '#',
                            displayValue: 'Hashtag'
                        },
                        {
                            value: 'other',
                            displayValue: 'Other'
                        }
                    ],
                    value: node.delimeter,
                        change: (val) => {
                            $('#node-input-delimeter-other-wrp').hide();
                            if (val === 'other') {
                                $('#node-input-delimeter-other-wrp').show();
                                $('#node-input-delimeter-other-wrp').show();
                            } else {
                                this.delimeterother = undefined;
                                document.getElementById('node-input-delimeterother').value = null;
                                $('#node-input-delimeter-other-wrp').hide();
                            }
                                validateForm();
                        }
                    });
                    delimeter.selectField('change', node.delimeter);

                /* Set values for key and value fields if already exists */
                if (node.header) {
                    document.getElementById('header-check').checked = true;
                }
                if (node.csvswitch) {
                    document.getElementById('csv-switch-check').checked = true;
                    $('#node-input-parsed-csv-wrp').hide();
                }
                if (node.relaxcolumnsize) {
                    document.getElementById('col-size-check').checked = true;
                }
                if (node.colparsetogglestate) {
                    populateExistingVariables('key', this.keyVariables);
                } else {
                    $('#key-props-section').hide();
                    $('#node-input-parse-col-wrp').show();
                    document.getElementById('parse-col-check').checked = node.parsecolumns;
                }
                if (node.skiplines) {
                    document.getElementById('skip-lines-check').checked = true;
                }
                if (node.byteordermark) {
                    document.getElementById('byte-order-check').checked = true;
                }
                if (node.csvsource) {
                    csvsource.typedInput('type', node.csvsource.type);
                    csvsource.typedInput('value', node.csvsource.value);
                }
                if (node.parsedcsv) {
                    parsedcsv.typedInput('type', node.parsedcsv.type);
                    parsedcsv.typedInput('value', node.parsedcsv.value);
                }
            },
            oneditsave: function () {
                const node = this;
                const csvsource = $('#node-input-csv-source');
                const parsedcsv = $('#node-input-parsed-csv');
                
                node.csvsource = { type: csvsource.typedInput('type'), value: csvsource.typedInput('value') };
                node.csvswitch = document.querySelector('input[id="csv-switch-check"]').checked;
                if (node.csvswitch) {
                    node.parsedcsv = undefined;
                } else {
                    node.parsedcsv = { type: parsedcsv.typedInput('type'), value: parsedcsv.typedInput('value') };
                }
                this.columns = {};
                node.header = { value: false };
                this.keyVariables = {};
                node.relaxcolumnsize = { value: false };
                node.skiplines = { value: false };
                node.byteordermark = { value: false };
                node.operationType = $('#node-select-operation').val();
                
                if (node.operationType === 'stringify') {
                    if (this.tempVarStore.columnVariables.length > 0) {
                        this.columns = this.tempVarStore.columnVariables.map(x => ({ key: x.key, header: x.header }));
                    }
                    node.header = document.querySelector('input[id="header-check"]').checked;
                    if ($('#node-select-delimeter').val() !== 'other') {
                        this.delimeterother = undefined;
                    }
                    
                } else  {
                    this.keyVariables = this.tempVarStore.keyVariables.map(x => ({ key: x.key }));
                    if (this.colparsetogglestate) {
                        node.parsecolumns = this.tempVarStore.keyVariables.map(x => ({ key: x.key }));
                    } else {
                        node.parsecolumns = document.querySelector('input[id="parse-col-check"]').checked
                    }
                    node.relaxcolumnsize = document.querySelector('input[id="col-size-check"]').checked;
                    node.skiplines = document.querySelector('input[id="skip-lines-check"]').checked;
                    node.byteordermark = document.querySelector('input[id="byte-order-check"]').checked; 
                    
                }

                delete this.tempVarStore; 
            },
            oneditcancel: function () {
                delete this.tempVarStore;
            },
            docsLink: 'csv-node'
        }
    });
</script>