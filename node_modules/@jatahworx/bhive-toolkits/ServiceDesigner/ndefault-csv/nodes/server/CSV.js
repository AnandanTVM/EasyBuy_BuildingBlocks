let BaseComponent = require("@jatahworx/bhive-toolkits").BaseComponent;
let path = require('path');
let SRDUtil = require('@jatahworx/bhive-toolkits').SRDCodeGenUtil;

module.exports = class CSV extends BaseComponent {
    constructor(constructorOptions) {
        super(constructorOptions.id, constructorOptions.name, "neutrinos_service_designer_CSV", "CSV");
        let srdUtil = new SRDUtil();
        let r = srdUtil.getTypedInputValues(constructorOptions);


        this.inputMapping = r.csvsource;
        this.resultMapping = r.parsedcsv;

        // csv stringify options
        // [ { key: 'a' }, { key: 'b' } ] | [ 'a', 'b' ] |  [ { key: 'a', header: 'col_a' }, { key: 'b', header: 'col_b' } ]
        this.columns = constructorOptions.columns;
        // The delimiter option set the delimiter between the fields of a record. It can be one or multiple characters. The default value is a comma ,
        this.delimiter = constructorOptions.delimeterother || constructorOptions.delimeter;
        // The header option generates the column names in the first emitted record. The value is expected to be a boolean value.
        this.header = constructorOptions.header;


        // if (!this.inputMapping || !this.resultMapping) {
        //     throw new Error(`CSV Node: inputMapping or resultMapping can't be empty`);
        // }

        // csv parser options
        // The columns option generates record in the form of object literals.
        //  columns: ['key_1', 'key_2'] || columns: true
        this.parseColumns = constructorOptions.parsecolumns; // boolean | array
        // The max_record_size option set a limit on the maximum number of characters to be contained in the field and line before an exception is raised.
        this.max_record_size = parseInt(constructorOptions.maxrecordsize); // number. default: 0
        // The relax_column_count option tolerates data sets with inconsistent number of fields between records.
        // By default, an error is thrown if two records have a different number of fields.
        this.relax_column_count = constructorOptions.relaxcolumnsize; // boolean. default: false
        // The skip_lines_with_error option tolerates parsing errors. 
        // It skips the records containing an error inside and directly go process the next record.
        this.skip_lines_with_error = constructorOptions.skiplines; // boolean. default: false
        // The bom option strip the byte order mark (BOM) from the input string or buffer.
        // When activated, the BOM is automatically detected and the parsing will occur whether a BOM was found or not.
        this.bom = constructorOptions.byteordermark;

        this.errorMapping = constructorOptions.errorMapping;
        this.viewType = 'server';
    }

    /**
     * returns Array of {
     *  libraryName: string,
     *  modules: [string],
     *  alias: string
     * }
     */
    generateImports(rootPaths) {
        return [{
            library: rootPaths.pathToUtilsRoot + '/ndefault-csv/CSV/CSVService',
            modules: ['CSVService']
        }];
    }

    generateSnippet() {
        let result = '';
        let csvoptions = '';
        let jsonoptions = '';
        if (!this.inputMapping ) {
            throw new Error(`CSV Node: inputMapping can't be empty`);
        }
        if (this.resultMapping) {
            result = this.resultMapping;
        } else {
            result = this.inputMapping;
        }
        if (this.parseColumns === "\ncolumns: [],") {
            csvoptions = `${this.max_record_size}${this.relax_column_count}${this.skip_lines_with_error}${this.bom}${this.delimiter}`;
        } else {
            csvoptions = `${this.parseColumns}${this.max_record_size}${this.relax_column_count}${this.skip_lines_with_error}${this.bom}${this.delimiter}`
        }
        if (this.columns === "\ncolumns: {},") {
            jsonoptions = `${this.header}${this.delimiter}`;
        } else {
            jsonoptions = `${this.columns}${this.header}${this.delimiter}`;
        }
        return `let csvServiceInstance = CSVService.getInstance();
                if (typeof ${this.inputMapping} === 'string') {
                    ${result} = await csvServiceInstance.csvToJson(${this.inputMapping}, {
                        ${csvoptions}
                    });
                } else if(typeof ${this.inputMapping} === 'object') {
                    ${result} = await csvServiceInstance.jsonToCsv(${this.inputMapping}, {
                        ${jsonoptions}
                    })
                } else {
                    throw new Error('Invalid input mapping type for CSV node. Only CSV string or CSV JSON is supported')
                }`;
    }



    get columns() {
        return this.__columns ? '\ncolumns: ' + this.__columns + ',': '';
    }

    set columns(columns) {
        if (typeof columns == 'object' || Array.isArray(columns)) {
            this.__columns = JSON.stringify(columns);
        }
    }

    get parseColumns() {
        return this.__parseColumns ? '\ncolumns: ' + this.__parseColumns + ',': '';
    }

    set parseColumns(parseColumns) {
        if (Array.isArray(parseColumns) ) {
            this.__parseColumns = JSON.stringify(parseColumns.map(x=>(x.key)));
        } else if (typeof parseColumns == 'boolean') {
            this.__parseColumns = JSON.stringify(parseColumns);
        }
    }

    get header() {
        return this.__header ? '\nheader: ' + this.__header + ',' : '';
    }

    set header(header) {
        if (typeof header == 'boolean') {
            this.__header = JSON.stringify(header);
        }
    }

    get delimiter() {
        return this.__delimiter ?  '\ndelimiter :' + this.__delimiter + ',': '';
    }

    set delimiter(delimiter) {
        if (typeof delimiter == 'string') {
            this.__delimiter = this.getSingleQuoted(delimiter);
        }
    }

    // https://csv.js.org/parse/options
    get max_record_size() {
        return typeof this.__max_record_size == 'number' ? '\nmax_record_size: ' + this.__max_record_size  + ',': '';
    }

    set max_record_size(max_record_size) {
        this.__max_record_size = max_record_size;
    }

    get relax_column_count() {
        return typeof this.__relax_column_count == 'boolean' ? '\nrelax_column_count: ' + this.__relax_column_count + ',': '';
    }

    set relax_column_count(relax_column_count) {
        this.__relax_column_count = relax_column_count;
    }

    get skip_lines_with_error() {
        return typeof this.__skip_lines_with_error == 'boolean' ? '\nskip_lines_with_error: ' + this.__skip_lines_with_error + ',' : '';
    }

    set skip_lines_with_error(skip_lines_with_error) {
        this.__skip_lines_with_error = skip_lines_with_error;
    }

    get bom() {
        return typeof this.__bom == 'boolean' ? '\nbom: ' + this.__bom + ',': '';
    }

    set bom(bom) {
        this.__bom = bom;
    }

    getSingleQuoted(value)  {
        if (value) {
            return `'${value}'`
        }
        return undefined;
    }

}
