let fsx = require("fs-extra");
let Start = require("../../ServiceDesigner/nodes/Start/Start");
let BaseComponent = require("../../ServiceDesigner/nodes/BaseComponent");
let prettier = require('prettier');
module.exports = class ServiceGenerator {
    constructor() {

    }

    createServiceClass(serviceName) {
        return new Promise((resolve, reject) => {
            // fsx.readFile("C:\\Users\\Anup Varma\\Documents\\GIT_Repo\\bhive-toolkits\\sandbox\\Nisarg\\ServiceTemplate.ts", "utf-8").then(template => {
                fsx.readFile("/Users/tulinisarg/bitbucket/bhive-toolkits/sandbox/Nisarg/ServiceTemplate.ts", "utf-8").then(template => {
                template = template.replace(/%serviceclassname%/g, serviceName);
                let servicPath = "generated/" + serviceName + ".ts";
                fsx.ensureFile(servicPath).then(() => {
                    fsx.writeFile(servicPath, template).then(() => {
                        return resolve(template);
                    }).catch(e => {
                        return reject(e);
                    });
                }).catch(e => {
                    return reject(e);
                });
            }).catch(e => {
                return reject(e);
            });
        });
    }

    insertAllFlows(flowsArray, serviceClassTemplate, serviceName) {
        return new Promise((resolve, reject) => {
            let allNodeNames = [];
            for (var i = 0; i < flowsArray.length; i++) {
                if (flowsArray[i] && flowsArray[i] instanceof Array) {
                    serviceClassTemplate = this.insertNewFlow(flowsArray[i], serviceClassTemplate, allNodeNames).serviceClassTemplate;
                }
                else {
                    return reject(new Error("Invalid arguments. 1st parameter must be an array of nodes"));
                }
            }
            let servicPath = "generated/" + serviceName + ".ts";
            serviceClassTemplate = prettier.format(serviceClassTemplate, { semi: false, parser: "typescript" });
            fsx.writeFile(servicPath, serviceClassTemplate).then(() => {
                return resolve();
            }).catch(e => {
                return reject(e);
            });
        });

    }

    insertNewFlow(sequentialNodeArray, serviceClassTemplate, allNodeNames, functionName) {
        let serviceName;
        for (var i = 0; i < sequentialNodeArray.length; i++) {
            switch (sequentialNodeArray[i]._nodeName) {
                case 'neutrinos_service_designer_start':
                    functionName = sequentialNodeArray[i].functionName;
                    serviceName = sequentialNodeArray[i].serviceName;
                    serviceClassTemplate = serviceClassTemplate.replace("//appendnew_flow_" + serviceName, sequentialNodeArray[i].generateSnippet() + "\n//appendnew_flow_" + serviceName);
                    break;
                default:
                    if (allNodeNames.indexOf(sequentialNodeArray[i]._displayName) > -1) {
                        // only call the script as the script is already added
                        serviceClassTemplate = serviceClassTemplate.replace("//appendnew_next_" + functionName, sequentialNodeArray[i].getCallTemplate() + "\n//appendnew_next_" + functionName);
                    }
                    else {
                        // generate the script node and call it
                        serviceClassTemplate = serviceClassTemplate.replace("//appendnew_node", sequentialNodeArray[i].generateSnippet(sequentialNodeArray[i].length_property) + "\n//appendnew_node");
                        serviceClassTemplate = serviceClassTemplate.replace("//appendnew_next_" + functionName, sequentialNodeArray[i].getCallTemplate() + "\n//appendnew_next_" + functionName);
                    }

                    // Check for sub flows and generate
                    if (sequentialNodeArray[i]._conditions) {
                        for (let j = 0; j < sequentialNodeArray[i]._conditions.length; j++) {
                            const condition = sequentialNodeArray[i]._conditions[j];
                            if (condition._nodeArray && condition._nodeArray instanceof Array && condition._nodeArray.length) {
                                let subFlowObj = this.insertNewFlow(condition._nodeArray, serviceClassTemplate, allNodeNames,  `${sequentialNodeArray[i]._displayName}_${j}`);
                                serviceClassTemplate = subFlowObj.serviceClassTemplate;
                                allNodeNames = subFlowObj.allNodeNames
                            }
                            else {
                                //throw new Error("Invalid arguments. 1st parameter must be an array of nodes");
                            }
                        }
                    } else {

                    }
                    break;
            }
            allNodeNames.push(sequentialNodeArray[i]._displayName);
        }
        return {
            serviceClassTemplate: serviceClassTemplate,
            allNodeNames: allNodeNames
        };
    }

    insertNewSubFlow(sequentialNodeArray, serviceClassTemplate, allNodeNames) {

        return {
            serviceClassTemplate: serviceClassTemplate,
            allNodeNames: allNodeNames
        }
    }

}