"use strict";
let AdvancedComponent = require("../../../core/AdvancedComponent");
let Attribute = require("../../../core/Attributes");
let htmlElementTypes=require('../../../attributeTypes/Html5').htmlAttributes;

module.exports = class html5 extends AdvancedComponent {
  constructor() {
    const name = "html-5";
    const designerTemplate = `
    <html-5 onclick="click(event)" component-label="HTML 5" class="drop-child drop ad-element">
        <html-editor n-adv-child> </html-editor>    
        <div slot="customHtml" class="inline-block">
            <button id="html-editor" class="add-child-button flex-column">HTML Editor</button>
        </div>
    </html-5>`;
    const paletteTemplate = "HTML 5";
    const componentLabel = 'HTML 5';
    const templateUrl = "articles/#!components-guide-7/html";
    super({
      name,
      template: ``,
      designerTemplate,
      paletteTemplate,
      templateUrl,
      componentLabel
    });
    super.setType(AdvancedComponent.COMPONENT_TYPE_TITLES.FORM_CONTROLS.val);
    super.addAttribute(new Attribute({
      key: 'htmlElement',
      value: 'div',
      type: 'dav',
      useAsLabel: true,
      templateUpdater: {
        valueChange: (elementValue, attribs) => {
          let componentInstance = this;
          let componentAttribute = componentInstance.getHtmlAttributes(attribs);
          let dynamicAttributes = {
            iframe: ['name', 'width', 'sandbox', 'src', 'srcdoc'],
            audio: ['[autoplay]', '[loop]', 'audioSource', '(audioplay)', '(audiopause)', '(audioended)', 'audioDatasource', 'audioSrc', 'audioType'],
            video: ['[autoplay]', '[loop]', 'videoSource', '(videoplay)', '(videopause)', '(videoended)', 'videoDatasource', 'videoSrc', 'videoType'],
            object: ['data'],
            youtube: ['name', 'width', 'sandbox', 'src', 'srcdoc']

          }

          this.hideShowAttributes(componentAttribute, dynamicAttributes[elementValue]);

          // getting the tag type value and sending to set template function for respective code generation
          let tagTypeAttribute = attribs.filter(attribute => attribute._key == "tagType");
          tagTypeAttribute[0]._value = elementValue;
          return attribs;
        }
      }
    }));
    super.addAttribute(new Attribute({
      key: 'tagType',
      value: '',
      type: 'a',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: 'name',
      value: '',
      type: 'kv',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: 'sandbox',
      value: '',
      type: 'kv',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: 'src',
      value: '',
      type: 'kv',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: 'srcdoc',
      value: '',
      type: 'kv',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: 'width',
      value: '',
      type: 'kv',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: '[autoplay]',
      value: '',
      type: 'kv',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: '[loop]',
      value: '',
      type: 'kv',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: 'data',
      value: '',
      type: 'kv',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: 'audioSource',
      value: [],
      type: 'a',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: 'videoSource',
      value: [],
      type: 'a',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: 'audioDatasource',
      value: '',
      type: 'a',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: 'audioSrc',
      value: '',
      type: 'a',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: 'audioType',
      value: '',
      type: 'a',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: 'videoDatasource',
      value: '',
      type: 'a',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: 'videoSrc',
      value: '',
      type: 'a',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: 'videoType',
      value: '',
      type: 'a',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: '(audioplay)',
      value: '',
      type: 'a',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: '(videoplay)',
      value: '',
      type: 'a',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: '(audiopause)',
      value: '',
      type: 'kv',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: '(videopause)',
      value: '',
      type: 'kv',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: '(audioended)',
      value: '',
      type: 'kv',
      visible: false
    }));
    super.addAttribute(new Attribute({
      key: '(videoended)',
      value: '',
      type: 'kv',
      visible: false
    }));
    super.composeTemplate({
      styles: `
      :host {
        border-radius: 2px;
        display: flex;
        position: relative;
        flex-direction: column;
        align-self: start;
      }`,
      slotsTemplate: `
      <slot name="customHtml"></slot>
      `,
      customMethods: {
        click: function (e) {
          if (e.target.id === "html-editor") {
            this.addChild("html-editor");
          }
        }
      }
    });
  }

  hideShowAttributes(componentAttributes, tagAttributeKeys) {
    let componentAttrLength = Object.keys(componentAttributes).length;
    let componentAttrKeys = Object.keys(componentAttributes);
    if (tagAttributeKeys != undefined) {
      for (let i = 0; i < componentAttrLength; i++) {
        if (tagAttributeKeys.indexOf(componentAttrKeys[i]) >= 0 && componentAttributes[componentAttrKeys[i]]._visibility == false) {
          componentAttributes[componentAttrKeys[i]]._visibility = true;
        }
        if (tagAttributeKeys.indexOf(componentAttrKeys[i]) < 0 && componentAttributes[componentAttrKeys[i]]._visibility == true) {
          componentAttributes[componentAttrKeys[i]]._visibility = false;
        }
      }
    } else {
      for (let i = 0; i < componentAttrLength; i++) {
        if (componentAttributes[componentAttrKeys[i]]._visibility == true) {
          componentAttributes[componentAttrKeys[i]]._visibility = false
        }
      }
    }
    return componentAttributes;
  }

  get template() {
    let template = '';
    let audioSourceTag = '';
    let videoSourceTag = '';
    let componentAttribute = this.getHtmlAttributes(this.htmlAttributes);
    let htmlElement = componentAttribute.tagType['_value'];
    let htmlSources = componentAttribute.audioSource['_value'];
    let htmlVideoSources = componentAttribute.videoSource['_value'];
    let audioPlayEvent = componentAttribute['(audioplay)']['_value'];
    let audioPauseEvent = componentAttribute['(audiopause)']['_value'];
    let audioEndedEvent = componentAttribute['(audioended)']['_value'];
    let videoPlayEvent = componentAttribute['(videoplay)']['_value'];
    let videoPauseEvent = componentAttribute['(videopause)']['_value'];
    let videoEndedEvent = componentAttribute['(videoended)']['_value'];
    if (htmlSources.length > 0) {
      for (let i = 0; i < htmlSources.length; i++) {
        audioSourceTag += `<source src="${htmlSources[i].input1}" type="${htmlElement}/${htmlSources[i].input2}">`;
      }
    }
    if (htmlVideoSources.length > 0){
      for (let i = 0; i < htmlVideoSources.length; i++) {
        videoSourceTag += `<source src="${htmlVideoSources[i].input1}" type="${htmlElement}/${htmlVideoSources[i].input2}">`;
      }
    }

    if (htmlElement == "audio") {
      if (componentAttribute['audioDatasource']._value.trim() != '') {
        template = `<%htmlElement% controls *ngFor=\"let audio of %audioDatasource%\" ${(audioPlayEvent.trim() != "") ? `(play)="${audioPlayEvent}"` : ''} ${(audioPauseEvent.trim() != "") ? `(pause)="${audioPauseEvent}"` : ''} ${(audioEndedEvent.trim() != "") ? `(ended)="${audioEndedEvent}"` : ''} %[autoplay]% %[loop]% %bCustomProps% %style% %class%>
                      <source src="{{%audioSrc%}}" type="${htmlElement}/{{%audioType%}}">
                    </%htmlElement%>`;
      } else {
        template = `<%htmlElement% controls ${(audioPlayEvent.trim() != "") ? `(play)="${audioPlayEvent}"` : ''} ${(audioPauseEvent.trim() != "") ? `(pause)="${audioPauseEvent}"` : ''} ${(audioEndedEvent.trim() != "") ? `(ended)="${audioEndedEvent}"` : ''}%[autoplay]% %[loop]% %bCustomProps% %style% %class%>
                    ${htmlSources.length > 0 ? `${audioSourceTag}` : ''}
                  </%htmlElement%>`;
      }
    } else if (htmlElement == "video") {
      if (componentAttribute['videoDatasource']._value.trim() != '') {
        template = `<%htmlElement% controls *ngFor=\"let video of %videoDatasource%\" ${(videoPlayEvent.trim() != "") ? `(play)="${videoPlayEvent}"` : ''} ${(videoPauseEvent.trim() != "") ? `(pause)="${videoPauseEvent}"` : ''} ${(videoEndedEvent.trim() != "") ? `(ended)="${videoEndedEvent}"` : ''}%[autoplay]% %[loop]% %bCustomProps% %style% %class%>
                      <source src="{{%videoSrc%}}" type="${htmlElement}/{{%videoType%}}">
                    </%htmlElement%>`;
      } else {
        template = `<%htmlElement% controls ${(videoPlayEvent.trim() != "") ? `(play)="${videoPlayEvent}"` : ''} ${(videoPauseEvent.trim() != "") ? `(pause)="${videoPauseEvent}"` : ''} ${(videoEndedEvent.trim() != "") ? `(ended)="${videoEndedEvent}"` : ''}%[autoplay]% %[loop]% %bCustomProps% %style% %class%>
                    ${htmlVideoSources.length > 0 ? `${videoSourceTag}` : ''}
                  </%htmlElement%>`;
      }
    } else if(htmlElement == "youtube") {
      template = `<iframe %data% %bCustomProps% %name% %sandbox% %src% %srcdoc% %width% %style% %class%>
      </iframe>`;
    } else {
      template = `<%htmlElement% %data% %bCustomProps% %name% %sandbox% %src% %srcdoc% %width% %style% %class%>
                </%htmlElement%>`;
    }
    return template;
  }

  onDrop({
    searchKey,
    designerReference
  }){
    let htmlElementAttr = designerReference.designerReference.find(attr => attr._key === 'htmlElement');
    let htmlTag=htmlElementTypes?.find(el=>el.value===searchKey.toLowerCase());
    if(htmlTag){
      htmlElementAttr._value=htmlTag?.value;
    }
  }

  set template(t) { }
};