module.exports = class Attributes {

	/**
	 * @typedef {Object} AttributeCtorOptions
	 * @property {string} key
	 * @property {any} value
	 * @property {string} type
	 * @property {string} [attrDef]
	 * @property {boolean} [useAsLabel]
	 * @property {TemplateUpdater} [templateUpdater]
	 * @property {boolean} [visible]
	 * @property {boolean} [isVisibleForParent]
	 * @property {string} [complexity]
	 */

	/**
	 * @typedef {Object} TemplateUpdater
	 * @property {(elmValue: any, designerRef: any, attributes: any[]) => string} [postSave]
	 * @property {() => string} [preRender]
	 * @property {<T>(value: any, selectedCompAttrs: T[]) => T[]} [valueChange]
	 */

	/** 
	 * @param {AttributeCtorOptions} attributeOptions 
	 */
    constructor(attributeOptions = {
            key: '',
            value: '',
            type: '',
            attrDef: '',
            useAsLabel: '',
            templateUpdater: {
                postSave: undefined,
                preRender: undefined,
                valueChange: undefined,
            },
            visible: '',
            isVisibleForParent: '',
            complexity: ''
        }) {
        let key = attributeOptions.key;
        let value = attributeOptions.value;
        let type = attributeOptions.type;
        let attrDef = attributeOptions.attrDef ? attributeOptions.attrDef : 'p';
        let useAsLabel = attributeOptions.useAsLabel;
        let templateUpdater = attributeOptions.templateUpdater;
        let visible = attributeOptions.visible;
        let isVisibleForParent = attributeOptions.isVisibleForParent;
        let complexity = attributeOptions.complexity;
        if (!key || !type || !attrDef) {
            throw new Error("Invalid Arguments");
        }

        if (type != "a" && type != "kv" && type != "ma" && type != "vk" && type != 'dav' && type != 'dialog') {
            throw new Error("Invalid Arguments. Attribute type can only be a(attribute) or kv(key-value) or ma(multi attribute) or vk(value-key) or dav(dynamic-attribute-value) or dialog");
        }

        if (attrDef != "p" && attrDef != "c") {
            throw new Error("Invalid Arguments. Attribute Defination can only be p(pre defined) or c(custom)");
        }

        this._key = key;
        this._value = value;
        this._type = type;
        this._attrDef = attrDef;
        this._complexity = complexity;
        if (useAsLabel) {
            this._useAsLabel = true;
        }
        if (templateUpdater) {
            if (typeof templateUpdater !== 'object' || (!templateUpdater.postSave && !templateUpdater.preRender && !templateUpdater.valueChange)) {
                throw new Error('Invalid Arguments. Attribute templateUpdater should of type object with postSave or preRender or valueChange methods implemented');
            }
            this._templateUpdater = templateUpdater;
        }
        if (typeof visible === 'boolean') {
            this._visibility = visible;
        }
        if (typeof isVisibleForParent === 'boolean') {
            this._isVisibleForParent = isVisibleForParent;
        }
    }

    get key() {
        return this._key;
    }

    set key(key) {
        this._key = key;
    }

    get value() {
        return this._value;
    }

    set value(value) {
        this._value = value;
    }

    get type() {
        return this._type;
    }

    set type(type) {
        if (type != "a" || type != "kv" || type != "ma" || type != "vk" || type != 'dav') {
            throw new Error("Invalid Arguments. Attribute type can only be a(attribute) or kv(key-value) or ma(multi attribute) or vk(value-key)");
        }
        this._type = type;
    }

    set attrDef(attrDef) {
        if (attrDef != "p" || attrDef != "c") {
            throw new Error("Invalid Arguments. Attribute Defination can only be p(pre defined) or c(custom)");
        }
        this._attrDef = attrDef;
    }

    get attrDef() {
        return this._attrDef;
    }

}